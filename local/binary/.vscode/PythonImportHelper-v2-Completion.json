[
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "frida",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "frida",
        "description": "frida",
        "detail": "frida",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "stderr",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "SEEK_CUR",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "SEEK_END",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "SEEK_SET",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "sha1",
        "importPath": "hashlib",
        "description": "hashlib",
        "isExtraImport": true,
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "sha1",
        "importPath": "hashlib",
        "description": "hashlib",
        "isExtraImport": true,
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "sha1",
        "importPath": "hashlib",
        "description": "hashlib",
        "isExtraImport": true,
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "AES",
        "importPath": "Crypto.Cipher",
        "description": "Crypto.Cipher",
        "isExtraImport": true,
        "detail": "Crypto.Cipher",
        "documentation": {}
    },
    {
        "label": "AES",
        "importPath": "Crypto.Cipher",
        "description": "Crypto.Cipher",
        "isExtraImport": true,
        "detail": "Crypto.Cipher",
        "documentation": {}
    },
    {
        "label": "AES",
        "importPath": "Crypto.Cipher",
        "description": "Crypto.Cipher",
        "isExtraImport": true,
        "detail": "Crypto.Cipher",
        "documentation": {}
    },
    {
        "label": "AES",
        "importPath": "Crypto.Cipher",
        "description": "Crypto.Cipher",
        "isExtraImport": true,
        "detail": "Crypto.Cipher",
        "documentation": {}
    },
    {
        "label": "struct",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "struct",
        "description": "struct",
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "unpack",
        "importPath": "struct",
        "description": "struct",
        "isExtraImport": true,
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "unpack",
        "importPath": "struct",
        "description": "struct",
        "isExtraImport": true,
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "unpack",
        "importPath": "struct",
        "description": "struct",
        "isExtraImport": true,
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "pack",
        "importPath": "struct",
        "description": "struct",
        "isExtraImport": true,
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "unpack",
        "importPath": "struct",
        "description": "struct",
        "isExtraImport": true,
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "unpack",
        "importPath": "struct",
        "description": "struct",
        "isExtraImport": true,
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "calcsize",
        "importPath": "struct",
        "description": "struct",
        "isExtraImport": true,
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "pack",
        "importPath": "struct",
        "description": "struct",
        "isExtraImport": true,
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "unpack",
        "importPath": "struct",
        "description": "struct",
        "isExtraImport": true,
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "calcsize",
        "importPath": "struct",
        "description": "struct",
        "isExtraImport": true,
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "binascii",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "binascii",
        "description": "binascii",
        "detail": "binascii",
        "documentation": {}
    },
    {
        "label": "unhexlify",
        "importPath": "binascii",
        "description": "binascii",
        "isExtraImport": true,
        "detail": "binascii",
        "documentation": {}
    },
    {
        "label": "hexlify",
        "importPath": "binascii",
        "description": "binascii",
        "isExtraImport": true,
        "detail": "binascii",
        "documentation": {}
    },
    {
        "label": "unhexlify",
        "importPath": "binascii",
        "description": "binascii",
        "isExtraImport": true,
        "detail": "binascii",
        "documentation": {}
    },
    {
        "label": "hexlify",
        "importPath": "binascii",
        "description": "binascii",
        "isExtraImport": true,
        "detail": "binascii",
        "documentation": {}
    },
    {
        "label": "unhexlify",
        "importPath": "binascii",
        "description": "binascii",
        "isExtraImport": true,
        "detail": "binascii",
        "documentation": {}
    },
    {
        "label": "hexlify",
        "importPath": "binascii",
        "description": "binascii",
        "isExtraImport": true,
        "detail": "binascii",
        "documentation": {}
    },
    {
        "label": "xml.etree.ElementTree",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xml.etree.ElementTree",
        "description": "xml.etree.ElementTree",
        "detail": "xml.etree.ElementTree",
        "documentation": {}
    },
    {
        "label": "zipfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zipfile",
        "description": "zipfile",
        "detail": "zipfile",
        "documentation": {}
    },
    {
        "label": "ZipFile",
        "importPath": "zipfile",
        "description": "zipfile",
        "isExtraImport": true,
        "detail": "zipfile",
        "documentation": {}
    },
    {
        "label": "MD5",
        "importPath": "Crypto.Hash",
        "description": "Crypto.Hash",
        "isExtraImport": true,
        "detail": "Crypto.Hash",
        "documentation": {}
    },
    {
        "label": "MD5",
        "importPath": "Crypto.Hash",
        "description": "Crypto.Hash",
        "isExtraImport": true,
        "detail": "Crypto.Hash",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "which",
        "importPath": "shutil",
        "description": "shutil",
        "isExtraImport": true,
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "docopt",
        "importPath": "docopt",
        "description": "docopt",
        "isExtraImport": true,
        "detail": "docopt",
        "documentation": {}
    },
    {
        "label": "docopt",
        "importPath": "docopt",
        "description": "docopt",
        "isExtraImport": true,
        "detail": "docopt",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "queue",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "queue",
        "description": "queue",
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "Queue",
        "importPath": "queue",
        "description": "queue",
        "isExtraImport": true,
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "mmap",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mmap",
        "description": "mmap",
        "detail": "mmap",
        "documentation": {}
    },
    {
        "label": "os.path",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.path",
        "description": "os.path",
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "update_metadata_pb2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "update_metadata_pb2",
        "description": "update_metadata_pb2",
        "detail": "update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "descriptor",
        "importPath": "google.protobuf",
        "description": "google.protobuf",
        "isExtraImport": true,
        "detail": "google.protobuf",
        "documentation": {}
    },
    {
        "label": "message",
        "importPath": "google.protobuf",
        "description": "google.protobuf",
        "isExtraImport": true,
        "detail": "google.protobuf",
        "documentation": {}
    },
    {
        "label": "reflection",
        "importPath": "google.protobuf",
        "description": "google.protobuf",
        "isExtraImport": true,
        "detail": "google.protobuf",
        "documentation": {}
    },
    {
        "label": "symbol_database",
        "importPath": "google.protobuf",
        "description": "google.protobuf",
        "isExtraImport": true,
        "detail": "google.protobuf",
        "documentation": {}
    },
    {
        "label": "descriptor",
        "importPath": "google.protobuf",
        "description": "google.protobuf",
        "isExtraImport": true,
        "detail": "google.protobuf",
        "documentation": {}
    },
    {
        "label": "message",
        "importPath": "google.protobuf",
        "description": "google.protobuf",
        "isExtraImport": true,
        "detail": "google.protobuf",
        "documentation": {}
    },
    {
        "label": "reflection",
        "importPath": "google.protobuf",
        "description": "google.protobuf",
        "isExtraImport": true,
        "detail": "google.protobuf",
        "documentation": {}
    },
    {
        "label": "symbol_database",
        "importPath": "google.protobuf",
        "description": "google.protobuf",
        "isExtraImport": true,
        "detail": "google.protobuf",
        "documentation": {}
    },
    {
        "label": "descriptor_pb2",
        "importPath": "google.protobuf",
        "description": "google.protobuf",
        "isExtraImport": true,
        "detail": "google.protobuf",
        "documentation": {}
    },
    {
        "label": "descriptor",
        "importPath": "google.protobuf",
        "description": "google.protobuf",
        "isExtraImport": true,
        "detail": "google.protobuf",
        "documentation": {}
    },
    {
        "label": "message",
        "importPath": "google.protobuf",
        "description": "google.protobuf",
        "isExtraImport": true,
        "detail": "google.protobuf",
        "documentation": {}
    },
    {
        "label": "reflection",
        "importPath": "google.protobuf",
        "description": "google.protobuf",
        "isExtraImport": true,
        "detail": "google.protobuf",
        "documentation": {}
    },
    {
        "label": "symbol_database",
        "importPath": "google.protobuf",
        "description": "google.protobuf",
        "isExtraImport": true,
        "detail": "google.protobuf",
        "documentation": {}
    },
    {
        "label": "descriptor_pb2",
        "importPath": "google.protobuf",
        "description": "google.protobuf",
        "isExtraImport": true,
        "detail": "google.protobuf",
        "documentation": {}
    },
    {
        "label": "bz2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "bz2",
        "description": "bz2",
        "detail": "bz2",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "bsdiff4",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "bsdiff4",
        "description": "bsdiff4",
        "detail": "bsdiff4",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "array",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "array",
        "description": "array",
        "detail": "array",
        "documentation": {}
    },
    {
        "label": "common",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "common",
        "description": "common",
        "detail": "common",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "heapq",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "heapq",
        "description": "heapq",
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "multiprocessing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "rangelib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "rangelib",
        "description": "rangelib",
        "detail": "rangelib",
        "documentation": {}
    },
    {
        "label": "RangeSet",
        "importPath": "rangelib",
        "description": "rangelib",
        "isExtraImport": true,
        "detail": "rangelib",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "errno",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "errno",
        "description": "errno",
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "getopt",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "getopt",
        "description": "getopt",
        "detail": "getopt",
        "documentation": {}
    },
    {
        "label": "getpass",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "getpass",
        "description": "getpass",
        "detail": "getpass",
        "documentation": {}
    },
    {
        "label": "imp",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "imp",
        "description": "imp",
        "detail": "imp",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "shlex",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shlex",
        "description": "shlex",
        "detail": "shlex",
        "documentation": {}
    },
    {
        "label": "blockimgdiff",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "blockimgdiff",
        "description": "blockimgdiff",
        "detail": "blockimgdiff",
        "documentation": {}
    },
    {
        "label": "sys,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys.",
        "description": "sys.",
        "detail": "sys.",
        "documentation": {}
    },
    {
        "label": "common,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "common.",
        "description": "common.",
        "detail": "common.",
        "documentation": {}
    },
    {
        "label": "bisect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "bisect",
        "description": "bisect",
        "detail": "bisect",
        "documentation": {}
    },
    {
        "label": "ctypes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ctypes",
        "description": "ctypes",
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "zlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zlib",
        "description": "zlib",
        "detail": "zlib",
        "documentation": {}
    },
    {
        "label": "IO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "mmap,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mmap.",
        "description": "mmap.",
        "detail": "mmap.",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "IntEnum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "on_message",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.backdoor",
        "description": "bin_oppo_decrypt.backdoor",
        "peekOfCode": "def on_message(message, data):\n    if (message[\"payload\"]==\"Output\"):\n        if (os.path.exists(\"test.data\")):\n            os.remove(\"test.data\")\n        with open(\"test.data\",\"wb\") as wf:\n            wf.write(data)\n    else:\n        print(\"Message: \"+str(message))\n        #print(\"[%s] => %s\" % (message, data))\ndef main(target_process):",
        "detail": "bin_oppo_decrypt.backdoor",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.backdoor",
        "description": "bin_oppo_decrypt.backdoor",
        "peekOfCode": "def main(target_process):\n    pid = frida.spawn([target_process])\n    session = frida.attach(pid)\n    script = session.create_script(\"\"\"\n    lang=Module.findExportByName(\"kernel32\",\"GetSystemDefaultLCID\");\n    Interceptor.attach(lang, { \n                        onEnter: function (args) {\n                            console.log('Found backdoor function');\n                        },\n                        // When function is finished",
        "detail": "bin_oppo_decrypt.backdoor",
        "documentation": {}
    },
    {
        "label": "swap",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_mtk_decrypt",
        "description": "bin_oppo_decrypt.ofp_mtk_decrypt",
        "peekOfCode": "def swap(ch):\n    return ((ch&0xF)<<4)+((ch&0xF0)>>4)\ndef keyshuffle(key,hkey):\n    for i in range(0,0x10,4):\n        key[i]=swap((hkey[i]^key[i]))\n        key[i+1]=swap(hkey[i+1]^key[i+1])\n        key[i+2]=swap(hkey[i+2]^key[i+2])\n        key[i+3]=swap(hkey[i+3]^key[i+3])\n    return key\ndef mtk_shuffle(key,keylength,input,inputlength):",
        "detail": "bin_oppo_decrypt.ofp_mtk_decrypt",
        "documentation": {}
    },
    {
        "label": "keyshuffle",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_mtk_decrypt",
        "description": "bin_oppo_decrypt.ofp_mtk_decrypt",
        "peekOfCode": "def keyshuffle(key,hkey):\n    for i in range(0,0x10,4):\n        key[i]=swap((hkey[i]^key[i]))\n        key[i+1]=swap(hkey[i+1]^key[i+1])\n        key[i+2]=swap(hkey[i+2]^key[i+2])\n        key[i+3]=swap(hkey[i+3]^key[i+3])\n    return key\ndef mtk_shuffle(key,keylength,input,inputlength):\n    for i in range(0,inputlength):\n        k=key[(i%keylength)]",
        "detail": "bin_oppo_decrypt.ofp_mtk_decrypt",
        "documentation": {}
    },
    {
        "label": "mtk_shuffle",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_mtk_decrypt",
        "description": "bin_oppo_decrypt.ofp_mtk_decrypt",
        "peekOfCode": "def mtk_shuffle(key,keylength,input,inputlength):\n    for i in range(0,inputlength):\n        k=key[(i%keylength)]\n        h=((((input[i]) & 0xF0) >> 4) | (16 * ((input[i]) & 0xF)))\n        input[i]=k ^ h\n    return input\ndef mtk_shuffle2(key,keylength,input,inputlength):\n    for i in range(0,inputlength):\n      tmp = key[i % keylength] ^ input[i]\n      input[i]=((tmp & 0xF0) >> 4) | (16 * (tmp & 0xF))",
        "detail": "bin_oppo_decrypt.ofp_mtk_decrypt",
        "documentation": {}
    },
    {
        "label": "mtk_shuffle2",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_mtk_decrypt",
        "description": "bin_oppo_decrypt.ofp_mtk_decrypt",
        "peekOfCode": "def mtk_shuffle2(key,keylength,input,inputlength):\n    for i in range(0,inputlength):\n      tmp = key[i % keylength] ^ input[i]\n      input[i]=((tmp & 0xF0) >> 4) | (16 * (tmp & 0xF))\n    return input\ndef aes_cfb(key, iv, data, decrypt=True, segment_size=128):\n    cipher = AES.new(key, AES.MODE_CFB,  IV=iv, segment_size=segment_size)\n    if decrypt:\n        plaintext = cipher.decrypt(data)\n        return plaintext",
        "detail": "bin_oppo_decrypt.ofp_mtk_decrypt",
        "documentation": {}
    },
    {
        "label": "aes_cfb",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_mtk_decrypt",
        "description": "bin_oppo_decrypt.ofp_mtk_decrypt",
        "peekOfCode": "def aes_cfb(key, iv, data, decrypt=True, segment_size=128):\n    cipher = AES.new(key, AES.MODE_CFB,  IV=iv, segment_size=segment_size)\n    if decrypt:\n        plaintext = cipher.decrypt(data)\n        return plaintext\n    else:\n        ciphertext = cipher.encrypt(data)\n        return ciphertext\nkeytables=[\n        [\"67657963787565E837D226B69A495D21\", #A77 CPH1715EX_11_A.04_170426, F1S A1601_MT6750_EX_11_A.15_160913 FW",
        "detail": "bin_oppo_decrypt.ofp_mtk_decrypt",
        "documentation": {}
    },
    {
        "label": "getkey",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_mtk_decrypt",
        "description": "bin_oppo_decrypt.ofp_mtk_decrypt",
        "peekOfCode": "def getkey(index):\n    kt=keytables[index]\n    if len(kt) == 3 :\n        obskey=bytearray(unhexlify(kt[0]))\n        encaeskey=bytearray(unhexlify(kt[1]))\n        encaesiv=bytearray(unhexlify(kt[2]))\n        aeskey=hexlify(hashlib.md5(mtk_shuffle2(obskey,16,encaeskey,16)).digest())[:16]\n        aesiv=hexlify(hashlib.md5(mtk_shuffle2(obskey, 16, encaesiv, 16)).digest())[:16]\n    else:\n        aeskey = bytes(kt[0],'utf-8')",
        "detail": "bin_oppo_decrypt.ofp_mtk_decrypt",
        "documentation": {}
    },
    {
        "label": "brutekey",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_mtk_decrypt",
        "description": "bin_oppo_decrypt.ofp_mtk_decrypt",
        "peekOfCode": "def brutekey(rf):\n    rf.seek(0)\n    encdata=rf.read(16)\n    for keyid in range(0,len(keytables)):\n        aeskey, aesiv = getkey(keyid)\n        data = aes_cfb(aeskey, aesiv, encdata, True)\n        if data[:3]==b\"MMM\":\n            return aeskey, aesiv\n    print(\"Unknown key. Please ask the author for support :)\")\n    exit(0)",
        "detail": "bin_oppo_decrypt.ofp_mtk_decrypt",
        "documentation": {}
    },
    {
        "label": "cleancstring",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_mtk_decrypt",
        "description": "bin_oppo_decrypt.ofp_mtk_decrypt",
        "peekOfCode": "def cleancstring(input):\n    return input.replace(b\"\\x00\",b\"\").decode('utf-8')\ndef main(filename,outdir):\n    if not os.path.exists(outdir):\n        os.mkdir(outdir)\n    hdrkey = bytearray(b\"geyixue\")\n    filesize=os.stat(filename).st_size\n    hdrlength=0x6C\n    with open(filename,'rb') as rf:\n        aeskey, aesiv = brutekey(rf)",
        "detail": "bin_oppo_decrypt.ofp_mtk_decrypt",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_mtk_decrypt",
        "description": "bin_oppo_decrypt.ofp_mtk_decrypt",
        "peekOfCode": "def main(filename,outdir):\n    if not os.path.exists(outdir):\n        os.mkdir(outdir)\n    hdrkey = bytearray(b\"geyixue\")\n    filesize=os.stat(filename).st_size\n    hdrlength=0x6C\n    with open(filename,'rb') as rf:\n        aeskey, aesiv = brutekey(rf)\n        rf.seek(filesize-hdrlength)\n        hdr = mtk_shuffle(hdrkey, len(hdrkey), bytearray(rf.read(hdrlength)), hdrlength)",
        "detail": "bin_oppo_decrypt.ofp_mtk_decrypt",
        "documentation": {}
    },
    {
        "label": "swap",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_decrypt",
        "description": "bin_oppo_decrypt.ofp_qc_decrypt",
        "peekOfCode": "def swap(ch):\n    return ((ch & 0xF) << 4) + ((ch & 0xF0) >> 4)\ndef keyshuffle(key, hkey):\n    for i in range(0, 0x10, 4):\n        key[i] = swap((hkey[i] ^ key[i]))\n        key[i + 1] = swap(hkey[i + 1] ^ key[i + 1])\n        key[i + 2] = swap(hkey[i + 2] ^ key[i + 2])\n        key[i + 3] = swap(hkey[i + 3] ^ key[i + 3])\n    return key\ndef ROR(x, n, bits = 32):",
        "detail": "bin_oppo_decrypt.ofp_qc_decrypt",
        "documentation": {}
    },
    {
        "label": "keyshuffle",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_decrypt",
        "description": "bin_oppo_decrypt.ofp_qc_decrypt",
        "peekOfCode": "def keyshuffle(key, hkey):\n    for i in range(0, 0x10, 4):\n        key[i] = swap((hkey[i] ^ key[i]))\n        key[i + 1] = swap(hkey[i + 1] ^ key[i + 1])\n        key[i + 2] = swap(hkey[i + 2] ^ key[i + 2])\n        key[i + 3] = swap(hkey[i + 3] ^ key[i + 3])\n    return key\ndef ROR(x, n, bits = 32):\n    mask = (2**n) - 1\n    mask_bits = x & mask",
        "detail": "bin_oppo_decrypt.ofp_qc_decrypt",
        "documentation": {}
    },
    {
        "label": "ROR",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_decrypt",
        "description": "bin_oppo_decrypt.ofp_qc_decrypt",
        "peekOfCode": "def ROR(x, n, bits = 32):\n    mask = (2**n) - 1\n    mask_bits = x & mask\n    return (x >> n) | (mask_bits << (bits - n))\ndef ROL(x, n, bits = 32):\n    return ROR(x, bits - n, bits)\ndef generatekey1():\n    key1 = \"42F2D5399137E2B2813CD8ECDF2F4D72\"\n    key2 = \"F6C50203515A2CE7D8C3E1F938B7E94C\"\n    key3 = \"67657963787565E837D226B69A495D21\"",
        "detail": "bin_oppo_decrypt.ofp_qc_decrypt",
        "documentation": {}
    },
    {
        "label": "ROL",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_decrypt",
        "description": "bin_oppo_decrypt.ofp_qc_decrypt",
        "peekOfCode": "def ROL(x, n, bits = 32):\n    return ROR(x, bits - n, bits)\ndef generatekey1():\n    key1 = \"42F2D5399137E2B2813CD8ECDF2F4D72\"\n    key2 = \"F6C50203515A2CE7D8C3E1F938B7E94C\"\n    key3 = \"67657963787565E837D226B69A495D21\"\n    key1 = bytearray.fromhex(key1)\n    key2 = bytearray.fromhex(key2)\n    key3 = bytearray.fromhex(key3)\n    key2 = keyshuffle(key2, key3)",
        "detail": "bin_oppo_decrypt.ofp_qc_decrypt",
        "documentation": {}
    },
    {
        "label": "generatekey1",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_decrypt",
        "description": "bin_oppo_decrypt.ofp_qc_decrypt",
        "peekOfCode": "def generatekey1():\n    key1 = \"42F2D5399137E2B2813CD8ECDF2F4D72\"\n    key2 = \"F6C50203515A2CE7D8C3E1F938B7E94C\"\n    key3 = \"67657963787565E837D226B69A495D21\"\n    key1 = bytearray.fromhex(key1)\n    key2 = bytearray.fromhex(key2)\n    key3 = bytearray.fromhex(key3)\n    key2 = keyshuffle(key2, key3)\n    aeskey = bytes(hashlib.md5(key2).hexdigest()[0:16], 'utf-8')\n    key1 = keyshuffle(key1, key3)",
        "detail": "bin_oppo_decrypt.ofp_qc_decrypt",
        "documentation": {}
    },
    {
        "label": "bytestolow",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_decrypt",
        "description": "bin_oppo_decrypt.ofp_qc_decrypt",
        "peekOfCode": "def bytestolow(data):\n    h = MD5.new()\n    h.update(data)\n    shash = h.digest()\n    return hexlify(shash).lower()[0:16]\ndef deobfuscate(data,mask):\n    ret=bytearray()\n    for i in range(0, len(data)):\n        v = ROL((data[i] ^ mask[i]), 4, 8)\n        ret.append(v)",
        "detail": "bin_oppo_decrypt.ofp_qc_decrypt",
        "documentation": {}
    },
    {
        "label": "deobfuscate",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_decrypt",
        "description": "bin_oppo_decrypt.ofp_qc_decrypt",
        "peekOfCode": "def deobfuscate(data,mask):\n    ret=bytearray()\n    for i in range(0, len(data)):\n        v = ROL((data[i] ^ mask[i]), 4, 8)\n        ret.append(v)\n    return ret\ndef generatekey2(filename):\n    keys = [\n        # R9s/A57t\n        [\"V1.4.17/1.4.27\",",
        "detail": "bin_oppo_decrypt.ofp_qc_decrypt",
        "documentation": {}
    },
    {
        "label": "generatekey2",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_decrypt",
        "description": "bin_oppo_decrypt.ofp_qc_decrypt",
        "peekOfCode": "def generatekey2(filename):\n    keys = [\n        # R9s/A57t\n        [\"V1.4.17/1.4.27\",\n         \"27827963787265EF89D126B69A495A21\",\n         \"82C50203285A2CE7D8C3E198383CE94C\",\n         \"422DD5399181E223813CD8ECDF2E4D72\"],\n        # a3s\n        [\"V1.6.17\",\n         \"E11AA7BB558A436A8375FD15DDD4651F\",",
        "detail": "bin_oppo_decrypt.ofp_qc_decrypt",
        "documentation": {}
    },
    {
        "label": "extract_xml",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_decrypt",
        "description": "bin_oppo_decrypt.ofp_qc_decrypt",
        "peekOfCode": "def extract_xml(filename,key,iv):\n    filesize=os.stat(filename).st_size\n    with open(filename,'rb') as rf:\n        pagesize = 0x200\n        xmloffset=filesize-pagesize\n        rf.seek(xmloffset+0x10)\n        if unpack(\"<I\",rf.read(4))[0]==0x7CEF:\n            pagesize=0x200\n        else:\n            pagesize=0x1000",
        "detail": "bin_oppo_decrypt.ofp_qc_decrypt",
        "documentation": {}
    },
    {
        "label": "aes_cfb",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_decrypt",
        "description": "bin_oppo_decrypt.ofp_qc_decrypt",
        "peekOfCode": "def aes_cfb(data,key,iv):\n    ctx = AES.new(key, AES.MODE_CFB, iv=iv, segment_size=128)\n    decrypted = ctx.decrypt(data)\n    return decrypted\ndef copysub(rf,wf,start,length):\n    rf.seek(start)\n    rlen=0\n    while length > 0:\n        if length < 0x100000:\n            size = length",
        "detail": "bin_oppo_decrypt.ofp_qc_decrypt",
        "documentation": {}
    },
    {
        "label": "copysub",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_decrypt",
        "description": "bin_oppo_decrypt.ofp_qc_decrypt",
        "peekOfCode": "def copysub(rf,wf,start,length):\n    rf.seek(start)\n    rlen=0\n    while length > 0:\n        if length < 0x100000:\n            size = length\n        else:\n            size = 0x100000\n        data = rf.read(size)\n        wf.write(data)",
        "detail": "bin_oppo_decrypt.ofp_qc_decrypt",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_decrypt",
        "description": "bin_oppo_decrypt.ofp_qc_decrypt",
        "peekOfCode": "def copy(filename,wfilename,path, start,length,checksums):\n    sha256sum=checksums[0]\n    md5sum=checksums[1]\n    print(f\"Extracting {wfilename}.\")\n    with open(filename, 'rb') as rf:\n        with open(os.path.join(path, wfilename), 'wb') as wf:\n            rf.seek(start)\n            data=rf.read(length)\n            wf.write(data)\n    with open(os.path.join(path, wfilename), \"rb\") as rf:",
        "detail": "bin_oppo_decrypt.ofp_qc_decrypt",
        "documentation": {}
    },
    {
        "label": "decryptfile",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_decrypt",
        "description": "bin_oppo_decrypt.ofp_qc_decrypt",
        "peekOfCode": "def decryptfile(key,iv,filename,path,wfilename,start,length,rlength,checksums,decryptsize=0x40000):\n    sha256sum = checksums[0]\n    md5sum = checksums[1]\n    print(f\"Extracting {wfilename}\")\n    if rlength==length:\n        tlen=length\n        length=(length//0x4*0x4)\n        if tlen%0x4!=0:\n            length+=0x4\n    with open(filename, 'rb') as rf:",
        "detail": "bin_oppo_decrypt.ofp_qc_decrypt",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_decrypt",
        "description": "bin_oppo_decrypt.ofp_qc_decrypt",
        "peekOfCode": "def main():\n    if len(sys.argv)<3:\n        print(\"Oppo MTK QC decrypt tool 1.1 (c) B.Kerler 2020-2021\\n\")\n        print(\"Usage: ./ofp_qc_extract.py [Filename.ofp] [Directory to extract files to]\")\n        sys.exit(1)\n    filename=sys.argv[1]\n    outdir=sys.argv[2]\n    if not os.path.exists(outdir):\n        os.mkdir(outdir)\n    pk=False",
        "detail": "bin_oppo_decrypt.ofp_qc_decrypt",
        "documentation": {}
    },
    {
        "label": "swap",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_extract",
        "description": "bin_oppo_decrypt.ofp_qc_extract",
        "peekOfCode": "def swap(ch):\n    return ((ch & 0xF) << 4) + ((ch & 0xF0) >> 4)\ndef keyshuffle(key, hkey):\n    for i in range(0, 0x10, 4):\n        key[i] = swap((hkey[i] ^ key[i]))\n        key[i + 1] = swap(hkey[i + 1] ^ key[i + 1])\n        key[i + 2] = swap(hkey[i + 2] ^ key[i + 2])\n        key[i + 3] = swap(hkey[i + 3] ^ key[i + 3])\n    return key\ndef ROR(x, n, bits = 32):",
        "detail": "bin_oppo_decrypt.ofp_qc_extract",
        "documentation": {}
    },
    {
        "label": "keyshuffle",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_extract",
        "description": "bin_oppo_decrypt.ofp_qc_extract",
        "peekOfCode": "def keyshuffle(key, hkey):\n    for i in range(0, 0x10, 4):\n        key[i] = swap((hkey[i] ^ key[i]))\n        key[i + 1] = swap(hkey[i + 1] ^ key[i + 1])\n        key[i + 2] = swap(hkey[i + 2] ^ key[i + 2])\n        key[i + 3] = swap(hkey[i + 3] ^ key[i + 3])\n    return key\ndef ROR(x, n, bits = 32):\n    mask = (2**n) - 1\n    mask_bits = x & mask",
        "detail": "bin_oppo_decrypt.ofp_qc_extract",
        "documentation": {}
    },
    {
        "label": "ROR",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_extract",
        "description": "bin_oppo_decrypt.ofp_qc_extract",
        "peekOfCode": "def ROR(x, n, bits = 32):\n    mask = (2**n) - 1\n    mask_bits = x & mask\n    return (x >> n) | (mask_bits << (bits - n))\ndef ROL(x, n, bits = 32):\n    return ROR(x, bits - n, bits)\ndef generatekey1():\n    key1 = \"42F2D5399137E2B2813CD8ECDF2F4D72\"\n    key2 = \"F6C50203515A2CE7D8C3E1F938B7E94C\"\n    key3 = \"67657963787565E837D226B69A495D21\"",
        "detail": "bin_oppo_decrypt.ofp_qc_extract",
        "documentation": {}
    },
    {
        "label": "ROL",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_extract",
        "description": "bin_oppo_decrypt.ofp_qc_extract",
        "peekOfCode": "def ROL(x, n, bits = 32):\n    return ROR(x, bits - n, bits)\ndef generatekey1():\n    key1 = \"42F2D5399137E2B2813CD8ECDF2F4D72\"\n    key2 = \"F6C50203515A2CE7D8C3E1F938B7E94C\"\n    key3 = \"67657963787565E837D226B69A495D21\"\n    key1 = bytearray.fromhex(key1)\n    key2 = bytearray.fromhex(key2)\n    key3 = bytearray.fromhex(key3)\n    key2 = keyshuffle(key2, key3)",
        "detail": "bin_oppo_decrypt.ofp_qc_extract",
        "documentation": {}
    },
    {
        "label": "generatekey1",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_extract",
        "description": "bin_oppo_decrypt.ofp_qc_extract",
        "peekOfCode": "def generatekey1():\n    key1 = \"42F2D5399137E2B2813CD8ECDF2F4D72\"\n    key2 = \"F6C50203515A2CE7D8C3E1F938B7E94C\"\n    key3 = \"67657963787565E837D226B69A495D21\"\n    key1 = bytearray.fromhex(key1)\n    key2 = bytearray.fromhex(key2)\n    key3 = bytearray.fromhex(key3)\n    key2 = keyshuffle(key2, key3)\n    aeskey = bytes(hashlib.md5(key2).hexdigest()[0:16], 'utf-8')\n    key1 = keyshuffle(key1, key3)",
        "detail": "bin_oppo_decrypt.ofp_qc_extract",
        "documentation": {}
    },
    {
        "label": "bytestolow",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_extract",
        "description": "bin_oppo_decrypt.ofp_qc_extract",
        "peekOfCode": "def bytestolow(data):\n    h = MD5.new()\n    h.update(data)\n    shash = h.digest()\n    return hexlify(shash).lower()[0:16]\ndef deobfuscate(data,mask):\n    ret=bytearray()\n    for i in range(0, len(data)):\n        v = ROL((data[i] ^ mask[i]), 4, 8)\n        ret.append(v)",
        "detail": "bin_oppo_decrypt.ofp_qc_extract",
        "documentation": {}
    },
    {
        "label": "deobfuscate",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_extract",
        "description": "bin_oppo_decrypt.ofp_qc_extract",
        "peekOfCode": "def deobfuscate(data,mask):\n    ret=bytearray()\n    for i in range(0, len(data)):\n        v = ROL((data[i] ^ mask[i]), 4, 8)\n        ret.append(v)\n    return ret\ndef generatekey2(filename):\n    keys = [\n                # a3s\n                [\"V1.6.17\", \"E11AA7BB558A436A8375FD15DDD4651F\", \"77DDF6A0696841F6B74782C097835169\",",
        "detail": "bin_oppo_decrypt.ofp_qc_extract",
        "documentation": {}
    },
    {
        "label": "generatekey2",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_extract",
        "description": "bin_oppo_decrypt.ofp_qc_extract",
        "peekOfCode": "def generatekey2(filename):\n    keys = [\n                # a3s\n                [\"V1.6.17\", \"E11AA7BB558A436A8375FD15DDD4651F\", \"77DDF6A0696841F6B74782C097835169\",\n                 \"A739742384A44E8BA45207AD5C3700EA\"],\n                #R9s/A57t\n                [\"V1.4.17/1.4.27\",                          \"27827963787265EF89D126B69A495A21\",\"82C50203285A2CE7D8C3E198383CE94C\",\"422DD5399181E223813CD8ECDF2E4D72\"],\n                [\"V1.5.13\",                                 \"67657963787565E837D226B69A495D21\",\"F6C50203515A2CE7D8C3E1F938B7E94C\",\"42F2D5399137E2B2813CD8ECDF2F4D72\"],\n                #R15 Pro CPH1831 V1.6.6 / FindX CPH1871 V1.6.9 / R17 Pro CPH1877 V1.6.17 / R17 PBEM00 V1.6.17 / A5 2020 V1.7.6 / K3 CPH1955 V1.6.26 UFS\n                #Reno 5G CPH1921 V1.6.26 / Realme 3 Pro RMX1851 V1.6.17 / Reno 10X Zoom V1.6.26 / R17 CPH1879 V1.6.17 / R17 Neo CPH1893 / K1 PBCM30",
        "detail": "bin_oppo_decrypt.ofp_qc_extract",
        "documentation": {}
    },
    {
        "label": "extract_xml",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_extract",
        "description": "bin_oppo_decrypt.ofp_qc_extract",
        "peekOfCode": "def extract_xml(filename,key,iv):\n    filesize=os.stat(filename).st_size\n    with open(filename,'rb') as rf:\n        pagesize = 0x200\n        xmloffset=filesize-pagesize\n        rf.seek(xmloffset+0x10)\n        if unpack(\"<I\",rf.read(4))[0]==0x7CEF:\n            pagesize=0x200\n        else:\n            pagesize=0x1000",
        "detail": "bin_oppo_decrypt.ofp_qc_extract",
        "documentation": {}
    },
    {
        "label": "aes_cfb",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_extract",
        "description": "bin_oppo_decrypt.ofp_qc_extract",
        "peekOfCode": "def aes_cfb(data,key,iv):\n    ctx = AES.new(key, AES.MODE_CFB, iv=iv, segment_size=128)\n    decrypted = ctx.decrypt(data)\n    return decrypted\ndef copysub(rf,wf,start,length):\n    rf.seek(start)\n    rlen=0\n    while length > 0:\n        if length < 0x100000:\n            size = length",
        "detail": "bin_oppo_decrypt.ofp_qc_extract",
        "documentation": {}
    },
    {
        "label": "copysub",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_extract",
        "description": "bin_oppo_decrypt.ofp_qc_extract",
        "peekOfCode": "def copysub(rf,wf,start,length):\n    rf.seek(start)\n    rlen=0\n    while length > 0:\n        if length < 0x100000:\n            size = length\n        else:\n            size = 0x100000\n        data = rf.read(size)\n        wf.write(data)",
        "detail": "bin_oppo_decrypt.ofp_qc_extract",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_extract",
        "description": "bin_oppo_decrypt.ofp_qc_extract",
        "peekOfCode": "def copy(filename,wfilename,path, start,length,checksums):\n    sha256sum=checksums[0]\n    md5sum=checksums[1]\n    print(f\"Extracting {wfilename}.\")\n    with open(filename, 'rb') as rf:\n        with open(os.path.join(path, wfilename), 'wb') as wf:\n            rf.seek(start)\n            data=rf.read(length)\n            wf.write(data)\n    with open(os.path.join(path, wfilename), \"rb\") as rf:",
        "detail": "bin_oppo_decrypt.ofp_qc_extract",
        "documentation": {}
    },
    {
        "label": "decryptfile",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_extract",
        "description": "bin_oppo_decrypt.ofp_qc_extract",
        "peekOfCode": "def decryptfile(key,iv,filename,path,wfilename,start,length,rlength,checksums,decryptsize=0x40000):\n    sha256sum = checksums[0]\n    md5sum = checksums[1]\n    print(f\"Extracting {wfilename}\")\n    if rlength==length:\n        tlen=length\n        length=(length//0x4*0x4)\n        if tlen%0x4!=0:\n            length+=0x4\n    with open(filename, 'rb') as rf:",
        "detail": "bin_oppo_decrypt.ofp_qc_extract",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ofp_qc_extract",
        "description": "bin_oppo_decrypt.ofp_qc_extract",
        "peekOfCode": "def main():\n    if len(sys.argv)<3:\n        print(\"Usage: ./ofp_qc_extract.py [Filename.ofp] [Directory to extract files to]\")\n        exit(0)\n    filename=sys.argv[1]\n    outdir=sys.argv[2]\n    if not os.path.exists(outdir):\n        os.mkdir(outdir)\n    pk=False\n    with open(filename,\"rb\") as rf:",
        "detail": "bin_oppo_decrypt.ofp_qc_extract",
        "documentation": {}
    },
    {
        "label": "QCSparse",
        "kind": 6,
        "importPath": "bin_oppo_decrypt.opscrypto",
        "description": "bin_oppo_decrypt.opscrypto",
        "peekOfCode": "class QCSparse:\n    def __init__(self, filename):\n        self.rf = mmap_io(filename,\"rb\")\n        self.data = Queue()\n        self.offset = 0\n        self.tmpdata = bytearray()\n        self.major_version = None\n        self.minor_version = None\n        self.file_hdr_sz = None\n        self.chunk_hdr_sz = None",
        "detail": "bin_oppo_decrypt.opscrypto",
        "documentation": {}
    },
    {
        "label": "mmap_io",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.opscrypto",
        "description": "bin_oppo_decrypt.opscrypto",
        "peekOfCode": "def mmap_io(filename, mode, length=0):\n    if mode==\"rb\":\n        with open(filename, mode=\"rb\") as file_obj:\n            return mmap.mmap(file_obj.fileno(), length=0, access=mmap.ACCESS_READ)\n    elif mode==\"wb\":\n        if os.path.exists(filename):\n            length=os.stat(filename).st_size\n        else:\n            with open(filename, \"wb\") as wf:\n                wf.write(length * b'\\0')",
        "detail": "bin_oppo_decrypt.opscrypto",
        "documentation": {}
    },
    {
        "label": "gsbox",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.opscrypto",
        "description": "bin_oppo_decrypt.opscrypto",
        "peekOfCode": "def gsbox(offset):\n    return int.from_bytes(sbox[offset:offset + 4],'little')\ndef key_update(iv1, asbox):\n    d = iv1[0] ^ asbox[0]  # 9EE3B5B1\n    a = iv1[1] ^ asbox[1]\n    b = iv1[2] ^ asbox[2]  # ABD51D58\n    c = iv1[3] ^ asbox[3]  # AFCBAFFF\n    e = gsbox(((b >> 0x10) & 0xff) * 8 + 2) ^ gsbox(((a >> 8) & 0xff) * 8 + 3) ^ gsbox((c >> 0x18) * 8 + 1) ^ \\\n        gsbox((d & 0xff) * 8) ^ asbox[4]  # 35C2A10B\n    h = gsbox(((c >> 0x10) & 0xff) * 8 + 2) ^ gsbox(((b >> 8) & 0xff) * 8 + 3) ^ gsbox((d >> 0x18) * 8 + 1) ^ \\",
        "detail": "bin_oppo_decrypt.opscrypto",
        "documentation": {}
    },
    {
        "label": "key_update",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.opscrypto",
        "description": "bin_oppo_decrypt.opscrypto",
        "peekOfCode": "def key_update(iv1, asbox):\n    d = iv1[0] ^ asbox[0]  # 9EE3B5B1\n    a = iv1[1] ^ asbox[1]\n    b = iv1[2] ^ asbox[2]  # ABD51D58\n    c = iv1[3] ^ asbox[3]  # AFCBAFFF\n    e = gsbox(((b >> 0x10) & 0xff) * 8 + 2) ^ gsbox(((a >> 8) & 0xff) * 8 + 3) ^ gsbox((c >> 0x18) * 8 + 1) ^ \\\n        gsbox((d & 0xff) * 8) ^ asbox[4]  # 35C2A10B\n    h = gsbox(((c >> 0x10) & 0xff) * 8 + 2) ^ gsbox(((b >> 8) & 0xff) * 8 + 3) ^ gsbox((d >> 0x18) * 8 + 1) ^ \\\n        gsbox((a & 0xff) * 8) ^ asbox[5]  # 75CF3118\n    i = gsbox(((d >> 0x10) & 0xff) * 8 + 2) ^ gsbox(((c >> 8) & 0xff) * 8 + 3) ^ gsbox((a >> 0x18) * 8 + 1) ^ \\",
        "detail": "bin_oppo_decrypt.opscrypto",
        "documentation": {}
    },
    {
        "label": "key_custom",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.opscrypto",
        "description": "bin_oppo_decrypt.opscrypto",
        "peekOfCode": "def key_custom(inp, rkey, outlength=0, encrypt=False):\n    outp = bytearray()\n    inp = bytearray(inp)\n    pos = outlength\n    outp_extend = outp.extend\n    ptr = 0\n    length = len(inp)\n    if outlength != 0:\n        while pos < len(rkey):\n            if length == 0:",
        "detail": "bin_oppo_decrypt.opscrypto",
        "documentation": {}
    },
    {
        "label": "extractxml",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.opscrypto",
        "description": "bin_oppo_decrypt.opscrypto",
        "peekOfCode": "def extractxml(filename, key):\n    with mmap_io(filename, 'rb') as rf:\n        sfilename = os.path.join(filename[:-len(os.path.basename(filename))], \"extract\", \"settings.xml\")\n        filesize = os.stat(filename).st_size\n        rf.seek(filesize - 0x200)\n        hdr = rf.read(0x200)\n        xmllength = int.from_bytes(hdr[0x18:0x18 + 4],'little')\n        xmlpad = 0x200 - (xmllength % 0x200)\n        rf.seek(filesize - 0x200 - (xmllength + xmlpad))\n        inp = rf.read(xmllength + xmlpad)",
        "detail": "bin_oppo_decrypt.opscrypto",
        "documentation": {}
    },
    {
        "label": "decryptfile",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.opscrypto",
        "description": "bin_oppo_decrypt.opscrypto",
        "peekOfCode": "def decryptfile(rkey, filename, path, wfilename, start, length):\n    sha256 = hashlib.sha256()\n    print(f\"Extracting {wfilename}\")\n    with mmap_io(filename, 'rb') as rf:\n        rf.seek(start)\n        data = rf.read(length)\n        if length % 4:\n            data += (4 - (length % 4)) * b'\\x00'\n        outp = key_custom(data, rkey, 0)\n        sha256.update(outp[:length])",
        "detail": "bin_oppo_decrypt.opscrypto",
        "documentation": {}
    },
    {
        "label": "encryptsubsub",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.opscrypto",
        "description": "bin_oppo_decrypt.opscrypto",
        "peekOfCode": "def encryptsubsub(rkey, data, wf):\n    length = len(data)\n    if length % 4:\n        data += (4 - (length % 4)) * b'\\x00'\n    outp = key_custom(data, rkey, 0, True)\n    wf.write(outp[:length])\n    return length\ndef encryptsub(rkey, rf, wf):\n    data = rf.read()\n    return encryptsubsub(rkey, data, wf)",
        "detail": "bin_oppo_decrypt.opscrypto",
        "documentation": {}
    },
    {
        "label": "encryptsub",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.opscrypto",
        "description": "bin_oppo_decrypt.opscrypto",
        "peekOfCode": "def encryptsub(rkey, rf, wf):\n    data = rf.read()\n    return encryptsubsub(rkey, data, wf)\ndef encryptfile(key, filename, wfilename):\n    print(f\"Encrypting {filename}\")\n    with mmap_io(filename, 'rb') as rf:\n        filesize=os.stat(filename).st_size\n        with mmap_io(wfilename, 'wb', filesize) as wf:\n            return encryptsub(key, rf, wf)\ndef calc_digest(filename):",
        "detail": "bin_oppo_decrypt.opscrypto",
        "documentation": {}
    },
    {
        "label": "encryptfile",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.opscrypto",
        "description": "bin_oppo_decrypt.opscrypto",
        "peekOfCode": "def encryptfile(key, filename, wfilename):\n    print(f\"Encrypting {filename}\")\n    with mmap_io(filename, 'rb') as rf:\n        filesize=os.stat(filename).st_size\n        with mmap_io(wfilename, 'wb', filesize) as wf:\n            return encryptsub(key, rf, wf)\ndef calc_digest(filename):\n    with mmap_io(filename, 'rb') as rf:\n        data = rf.read()\n        sha256 = hashlib.sha256()",
        "detail": "bin_oppo_decrypt.opscrypto",
        "documentation": {}
    },
    {
        "label": "calc_digest",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.opscrypto",
        "description": "bin_oppo_decrypt.opscrypto",
        "peekOfCode": "def calc_digest(filename):\n    with mmap_io(filename, 'rb') as rf:\n        data = rf.read()\n        sha256 = hashlib.sha256()\n        sha256.update(data)\n        if len(data) % 0x1000 > 0:\n            sha256.update(b\"\\x00\" * (0x1000 - (len(data) % 0x1000)))\n    return sha256.hexdigest()\ndef copysub(rf, wf, start, length):\n    rf.seek(start)",
        "detail": "bin_oppo_decrypt.opscrypto",
        "documentation": {}
    },
    {
        "label": "copysub",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.opscrypto",
        "description": "bin_oppo_decrypt.opscrypto",
        "peekOfCode": "def copysub(rf, wf, start, length):\n    rf.seek(start)\n    rlen = 0\n    while length > 0:\n        if length < 0x100000:\n            size = length\n        else:\n            size = 0x100000\n        data = rf.read(size)\n        wf.write(data)",
        "detail": "bin_oppo_decrypt.opscrypto",
        "documentation": {}
    },
    {
        "label": "copyfile",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.opscrypto",
        "description": "bin_oppo_decrypt.opscrypto",
        "peekOfCode": "def copyfile(filename, path, wfilename, start, length):\n    print(f\"Extracting {wfilename}\")\n    with mmap_io(filename, 'rb') as rf:\n        with mmap_io(os.path.join(path, wfilename), 'wb', length) as wf:\n            return copysub(rf, wf, start, length)\ndef encryptitem(key, item, directory, pos, wf):\n    try:\n        filename = item.attrib[\"Path\"]\n    except:\n        filename = item.attrib[\"filename\"]",
        "detail": "bin_oppo_decrypt.opscrypto",
        "documentation": {}
    },
    {
        "label": "encryptitem",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.opscrypto",
        "description": "bin_oppo_decrypt.opscrypto",
        "peekOfCode": "def encryptitem(key, item, directory, pos, wf):\n    try:\n        filename = item.attrib[\"Path\"]\n    except:\n        filename = item.attrib[\"filename\"]\n    if filename == \"\":\n        return item, pos\n    filename = os.path.join(directory, filename)\n    start = pos // 0x200\n    item.attrib[\"FileOffsetInSrc\"] = str(start)",
        "detail": "bin_oppo_decrypt.opscrypto",
        "documentation": {}
    },
    {
        "label": "copyitem",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.opscrypto",
        "description": "bin_oppo_decrypt.opscrypto",
        "peekOfCode": "def copyitem(item, directory, pos, wf):\n    try:\n        filename = item.attrib[\"Path\"]\n    except:\n        filename = item.attrib[\"filename\"]\n    if filename == \"\":\n        return item, pos\n    filename = os.path.join(directory, filename)\n    start = pos // 0x200\n    item.attrib[\"FileOffsetInSrc\"] = str(start)",
        "detail": "bin_oppo_decrypt.opscrypto",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.opscrypto",
        "description": "bin_oppo_decrypt.opscrypto",
        "peekOfCode": "def main():\n    global mbox\n    print(\"Oneplus CryptTools V1.4 (c) B. Kerler 2019-2021\\n----------------------------\\n\")\n    if args[\"decrypt\"]:\n        filename = args[\"<filename>\"].replace(\"\\\\\", \"/\")\n        print(f\"Extracting {filename}\")\n        if \"/\" in filename:\n            path = filename[:filename.rfind(\"/\")]\n        else:\n            path = \"\"",
        "detail": "bin_oppo_decrypt.opscrypto",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "bin_oppo_decrypt.opscrypto",
        "description": "bin_oppo_decrypt.opscrypto",
        "peekOfCode": "args = docopt(__doc__, version='1.2')\nimport shutil\nimport os\nfrom struct import pack, unpack\nimport xml.etree.ElementTree as ET\nimport hashlib\nfrom pathlib import Path\nfrom queue import Queue\nimport mmap\ndef mmap_io(filename, mode, length=0):",
        "detail": "bin_oppo_decrypt.opscrypto",
        "documentation": {}
    },
    {
        "label": "key",
        "kind": 5,
        "importPath": "bin_oppo_decrypt.opscrypto",
        "description": "bin_oppo_decrypt.opscrypto",
        "peekOfCode": "key = unpack(\"<4I\", bytes.fromhex(\"d1b5e39e5eea049d671dd5abd2afcbaf\"))\n# guacamoles_31_O.09_190820\nmbox5 = [0x60, 0x8a, 0x3f, 0x2d, 0x68, 0x6b, 0xd4, 0x23, 0x51, 0x0c,\n         0xd0, 0x95, 0xbb, 0x40, 0xe9, 0x76, 0x00, 0x00, 0x00, 0x00,\n         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n         0x0a, 0x00]\n# instantnoodlev_15_O.07_201103",
        "detail": "bin_oppo_decrypt.opscrypto",
        "documentation": {}
    },
    {
        "label": "mbox5",
        "kind": 5,
        "importPath": "bin_oppo_decrypt.opscrypto",
        "description": "bin_oppo_decrypt.opscrypto",
        "peekOfCode": "mbox5 = [0x60, 0x8a, 0x3f, 0x2d, 0x68, 0x6b, 0xd4, 0x23, 0x51, 0x0c,\n         0xd0, 0x95, 0xbb, 0x40, 0xe9, 0x76, 0x00, 0x00, 0x00, 0x00,\n         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n         0x0a, 0x00]\n# instantnoodlev_15_O.07_201103\nmbox6 = [0xAA, 0x69, 0x82, 0x9E, 0x5D, 0xDE, 0xB1, 0x3D, 0x30, 0xBB,\n         0x81, 0xA3, 0x46, 0x65, 0xa3, 0xe1, 0x00, 0x00, 0x00, 0x00,",
        "detail": "bin_oppo_decrypt.opscrypto",
        "documentation": {}
    },
    {
        "label": "mbox6",
        "kind": 5,
        "importPath": "bin_oppo_decrypt.opscrypto",
        "description": "bin_oppo_decrypt.opscrypto",
        "peekOfCode": "mbox6 = [0xAA, 0x69, 0x82, 0x9E, 0x5D, 0xDE, 0xB1, 0x3D, 0x30, 0xBB,\n         0x81, 0xA3, 0x46, 0x65, 0xa3, 0xe1, 0x00, 0x00, 0x00, 0x00,\n         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n         0x0a, 0x00]\n# guacamolet_21_O.08_190502\nmbox4 = [0xC4, 0x5D, 0x05, 0x71, 0x99, 0xDD, 0xBB, 0xEE, 0x29, 0xA1,\n         0x6D, 0xC7, 0xAD, 0xBF, 0xA4, 0x3F, 0x00, 0x00, 0x00, 0x00,",
        "detail": "bin_oppo_decrypt.opscrypto",
        "documentation": {}
    },
    {
        "label": "mbox4",
        "kind": 5,
        "importPath": "bin_oppo_decrypt.opscrypto",
        "description": "bin_oppo_decrypt.opscrypto",
        "peekOfCode": "mbox4 = [0xC4, 0x5D, 0x05, 0x71, 0x99, 0xDD, 0xBB, 0xEE, 0x29, 0xA1,\n         0x6D, 0xC7, 0xAD, 0xBF, 0xA4, 0x3F, 0x00, 0x00, 0x00, 0x00,\n         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n         0x0a, 0x00]\nsbox = bytes.fromhex(\"c66363a5c66363a5f87c7c84f87c7c84ee777799ee777799f67b7b8df67b7b8d\" +\n                     \"fff2f20dfff2f20dd66b6bbdd66b6bbdde6f6fb1de6f6fb191c5c55491c5c554\" +\n                     \"60303050603030500201010302010103ce6767a9ce6767a9562b2b7d562b2b7d\" +",
        "detail": "bin_oppo_decrypt.opscrypto",
        "documentation": {}
    },
    {
        "label": "sbox",
        "kind": 5,
        "importPath": "bin_oppo_decrypt.opscrypto",
        "description": "bin_oppo_decrypt.opscrypto",
        "peekOfCode": "sbox = bytes.fromhex(\"c66363a5c66363a5f87c7c84f87c7c84ee777799ee777799f67b7b8df67b7b8d\" +\n                     \"fff2f20dfff2f20dd66b6bbdd66b6bbdde6f6fb1de6f6fb191c5c55491c5c554\" +\n                     \"60303050603030500201010302010103ce6767a9ce6767a9562b2b7d562b2b7d\" +\n                     \"e7fefe19e7fefe19b5d7d762b5d7d7624dababe64dababe6ec76769aec76769a\" +\n                     \"8fcaca458fcaca451f82829d1f82829d89c9c94089c9c940fa7d7d87fa7d7d87\" +\n                     \"effafa15effafa15b25959ebb25959eb8e4747c98e4747c9fbf0f00bfbf0f00b\" +\n                     \"41adadec41adadecb3d4d467b3d4d4675fa2a2fd5fa2a2fd45afafea45afafea\" +\n                     \"239c9cbf239c9cbf53a4a4f753a4a4f7e4727296e47272969bc0c05b9bc0c05b\" +\n                     \"75b7b7c275b7b7c2e1fdfd1ce1fdfd1c3d9393ae3d9393ae4c26266a4c26266a\" +\n                     \"6c36365a6c36365a7e3f3f417e3f3f41f5f7f702f5f7f70283cccc4f83cccc4f\" +",
        "detail": "bin_oppo_decrypt.opscrypto",
        "documentation": {}
    },
    {
        "label": "on_message",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ops_decrypt_frida",
        "description": "bin_oppo_decrypt.ops_decrypt_frida",
        "peekOfCode": "def on_message(message, data):\n    global i\n    if \"payload\" in message:\n        if (message[\"payload\"]==\"Output\"):\n            if os.path.exists(\"decrypted.data\"+str(i)):\n                os.remove(\"decrypted.data\"+str(i))\n            with open(\"decrypted.data\"+str(i),\"wb\") as wf:\n                wf.write(data)\n                print(\"Decrypted data was written to 'decrypted.data\"+str(i)+\"'.\")\n            i+=1",
        "detail": "bin_oppo_decrypt.ops_decrypt_frida",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "bin_oppo_decrypt.ops_decrypt_frida",
        "description": "bin_oppo_decrypt.ops_decrypt_frida",
        "peekOfCode": "def main(target_process):\n    pid = frida.spawn([target_process])\n    session = frida.attach(pid)\n    script = session.create_script(\"\"\"\n    var seekoffset=0;\n    var seeklength=0;\n    var processname=\"\";\n    var op = recv('param', function(value) {\n                var v = value.payload.split(\",\");\n                processname = v[0];",
        "detail": "bin_oppo_decrypt.ops_decrypt_frida",
        "documentation": {}
    },
    {
        "label": "PayloadError",
        "kind": 6,
        "importPath": "bin_payload.extract_payload-master.extract_payload",
        "description": "bin_payload.extract_payload-master.extract_payload",
        "peekOfCode": "class PayloadError(Exception):\n  pass\nclass Payload(object):\n  class _PayloadHeader(object):\n    _MAGIC = b'CrAU'\n    def __init__(self):\n      self.version = None\n      self.manifest_len = None\n      self.metadata_signature_len = None\n      self.size = None",
        "detail": "bin_payload.extract_payload-master.extract_payload",
        "documentation": {}
    },
    {
        "label": "Payload",
        "kind": 6,
        "importPath": "bin_payload.extract_payload-master.extract_payload",
        "description": "bin_payload.extract_payload-master.extract_payload",
        "peekOfCode": "class Payload(object):\n  class _PayloadHeader(object):\n    _MAGIC = b'CrAU'\n    def __init__(self):\n      self.version = None\n      self.manifest_len = None\n      self.metadata_signature_len = None\n      self.size = None\n    def ReadFromPayload(self, payload_file):\n      magic = payload_file.read(4)",
        "detail": "bin_payload.extract_payload-master.extract_payload",
        "documentation": {}
    },
    {
        "label": "decompress_payload",
        "kind": 2,
        "importPath": "bin_payload.extract_payload-master.extract_payload",
        "description": "bin_payload.extract_payload-master.extract_payload",
        "peekOfCode": "def decompress_payload(command, data, size, hash):\n  p = subprocess.Popen([command, '-'], stdout=subprocess.PIPE, stdin=subprocess.PIPE)\n  r = p.communicate(data)[0]\n  if len(r) != size:\n    print(\"Unexpected size %d %d\" % (len(r), size))\n  elif hashlib.sha256(data).digest() != hash:\n    print(\"Hash mismatch\")\n  return r\ndef parse_payload(payload_f, partition, out_f):\n  BLOCK_SIZE = 4096",
        "detail": "bin_payload.extract_payload-master.extract_payload",
        "documentation": {}
    },
    {
        "label": "parse_payload",
        "kind": 2,
        "importPath": "bin_payload.extract_payload-master.extract_payload",
        "description": "bin_payload.extract_payload-master.extract_payload",
        "peekOfCode": "def parse_payload(payload_f, partition, out_f):\n  BLOCK_SIZE = 4096\n  for operation in partition.operations:\n    e = operation.dst_extents[0]\n    data = payload_f.ReadDataBlob(operation.data_offset, operation.data_length)\n    out_f.seek(e.start_block * BLOCK_SIZE)\n    if operation.type == update_metadata_pb2.InstallOperation.REPLACE:\n      out_f.write(data)\n    elif operation.type == update_metadata_pb2.InstallOperation.REPLACE_XZ:\n      r = decompress_payload('xzcat', data, e.num_blocks * BLOCK_SIZE, operation.data_sha256_hash)",
        "detail": "bin_payload.extract_payload-master.extract_payload",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "bin_payload.extract_payload-master.extract_payload",
        "description": "bin_payload.extract_payload-master.extract_payload",
        "peekOfCode": "def main(filename, output_dir):\n  if filename.endswith('.zip'):\n    print(\"Extracting 'payload.bin' from OTA file...\")\n    ota_zf = zipfile.ZipFile(filename)\n    payload_file = open(ota_zf.extract('payload.bin', output_dir), 'rb')\n  else:\n    payload_file = open(filename, 'rb')\n  payload = Payload(payload_file)\n  payload.Init()\n  for p in payload.manifest.partitions:",
        "detail": "bin_payload.extract_payload-master.extract_payload",
        "documentation": {}
    },
    {
        "label": "PROGRAMS",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.extract_payload",
        "description": "bin_payload.extract_payload-master.extract_payload",
        "peekOfCode": "PROGRAMS = [ 'bzcat', 'xzcat' ]\nBRILLO_MAJOR_PAYLOAD_VERSION = 2\nclass PayloadError(Exception):\n  pass\nclass Payload(object):\n  class _PayloadHeader(object):\n    _MAGIC = b'CrAU'\n    def __init__(self):\n      self.version = None\n      self.manifest_len = None",
        "detail": "bin_payload.extract_payload-master.extract_payload",
        "documentation": {}
    },
    {
        "label": "BRILLO_MAJOR_PAYLOAD_VERSION",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.extract_payload",
        "description": "bin_payload.extract_payload-master.extract_payload",
        "peekOfCode": "BRILLO_MAJOR_PAYLOAD_VERSION = 2\nclass PayloadError(Exception):\n  pass\nclass Payload(object):\n  class _PayloadHeader(object):\n    _MAGIC = b'CrAU'\n    def __init__(self):\n      self.version = None\n      self.manifest_len = None\n      self.metadata_signature_len = None",
        "detail": "bin_payload.extract_payload-master.extract_payload",
        "documentation": {}
    },
    {
        "label": "_sym_db",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_sym_db = _symbol_database.Default()\nDESCRIPTOR = _descriptor.FileDescriptor(\n  name='update_metadata.proto',\n  package='chromeos_update_engine',\n  syntax='proto2',\n  serialized_options=_b('H\\003'),\n  serialized_pb=_b('\\n\\x15update_metadata.proto\\x12\\x16\\x63hromeos_update_engine\\\"1\\n\\x06\\x45xtent\\x12\\x13\\n\\x0bstart_block\\x18\\x01 \\x01(\\x04\\x12\\x12\\n\\nnum_blocks\\x18\\x02 \\x01(\\x04\\\"z\\n\\nSignatures\\x12@\\n\\nsignatures\\x18\\x01 \\x03(\\x0b\\x32,.chromeos_update_engine.Signatures.Signature\\x1a*\\n\\tSignature\\x12\\x0f\\n\\x07version\\x18\\x01 \\x01(\\r\\x12\\x0c\\n\\x04\\x64\\x61ta\\x18\\x02 \\x01(\\x0c\\\"+\\n\\rPartitionInfo\\x12\\x0c\\n\\x04size\\x18\\x01 \\x01(\\x04\\x12\\x0c\\n\\x04hash\\x18\\x02 \\x01(\\x0c\\\"w\\n\\tImageInfo\\x12\\r\\n\\x05\\x62oard\\x18\\x01 \\x01(\\t\\x12\\x0b\\n\\x03key\\x18\\x02 \\x01(\\t\\x12\\x0f\\n\\x07\\x63hannel\\x18\\x03 \\x01(\\t\\x12\\x0f\\n\\x07version\\x18\\x04 \\x01(\\t\\x12\\x15\\n\\rbuild_channel\\x18\\x05 \\x01(\\t\\x12\\x15\\n\\rbuild_version\\x18\\x06 \\x01(\\t\\\"\\xee\\x03\\n\\x10InstallOperation\\x12;\\n\\x04type\\x18\\x01 \\x02(\\x0e\\x32-.chromeos_update_engine.InstallOperation.Type\\x12\\x13\\n\\x0b\\x64\\x61ta_offset\\x18\\x02 \\x01(\\x04\\x12\\x13\\n\\x0b\\x64\\x61ta_length\\x18\\x03 \\x01(\\x04\\x12\\x33\\n\\x0bsrc_extents\\x18\\x04 \\x03(\\x0b\\x32\\x1e.chromeos_update_engine.Extent\\x12\\x12\\n\\nsrc_length\\x18\\x05 \\x01(\\x04\\x12\\x33\\n\\x0b\\x64st_extents\\x18\\x06 \\x03(\\x0b\\x32\\x1e.chromeos_update_engine.Extent\\x12\\x12\\n\\ndst_length\\x18\\x07 \\x01(\\x04\\x12\\x18\\n\\x10\\x64\\x61ta_sha256_hash\\x18\\x08 \\x01(\\x0c\\x12\\x17\\n\\x0fsrc_sha256_hash\\x18\\t \\x01(\\x0c\\\"\\xad\\x01\\n\\x04Type\\x12\\x0b\\n\\x07REPLACE\\x10\\x00\\x12\\x0e\\n\\nREPLACE_BZ\\x10\\x01\\x12\\x0c\\n\\x04MOVE\\x10\\x02\\x1a\\x02\\x08\\x01\\x12\\x0e\\n\\x06\\x42SDIFF\\x10\\x03\\x1a\\x02\\x08\\x01\\x12\\x0f\\n\\x0bSOURCE_COPY\\x10\\x04\\x12\\x11\\n\\rSOURCE_BSDIFF\\x10\\x05\\x12\\x0e\\n\\nREPLACE_XZ\\x10\\x08\\x12\\x08\\n\\x04ZERO\\x10\\x06\\x12\\x0b\\n\\x07\\x44ISCARD\\x10\\x07\\x12\\x11\\n\\rBROTLI_BSDIFF\\x10\\n\\x12\\x0c\\n\\x08PUFFDIFF\\x10\\t\\\"\\xd7\\x05\\n\\x0fPartitionUpdate\\x12\\x16\\n\\x0epartition_name\\x18\\x01 \\x02(\\t\\x12\\x17\\n\\x0frun_postinstall\\x18\\x02 \\x01(\\x08\\x12\\x18\\n\\x10postinstall_path\\x18\\x03 \\x01(\\t\\x12\\x17\\n\\x0f\\x66ilesystem_type\\x18\\x04 \\x01(\\t\\x12M\\n\\x17new_partition_signature\\x18\\x05 \\x03(\\x0b\\x32,.chromeos_update_engine.Signatures.Signature\\x12\\x41\\n\\x12old_partition_info\\x18\\x06 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12\\x41\\n\\x12new_partition_info\\x18\\x07 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12<\\n\\noperations\\x18\\x08 \\x03(\\x0b\\x32(.chromeos_update_engine.InstallOperation\\x12\\x1c\\n\\x14postinstall_optional\\x18\\t \\x01(\\x08\\x12=\\n\\x15hash_tree_data_extent\\x18\\n \\x01(\\x0b\\x32\\x1e.chromeos_update_engine.Extent\\x12\\x38\\n\\x10hash_tree_extent\\x18\\x0b \\x01(\\x0b\\x32\\x1e.chromeos_update_engine.Extent\\x12\\x1b\\n\\x13hash_tree_algorithm\\x18\\x0c \\x01(\\t\\x12\\x16\\n\\x0ehash_tree_salt\\x18\\r \\x01(\\x0c\\x12\\x37\\n\\x0f\\x66\\x65\\x63_data_extent\\x18\\x0e \\x01(\\x0b\\x32\\x1e.chromeos_update_engine.Extent\\x12\\x32\\n\\nfec_extent\\x18\\x0f \\x01(\\x0b\\x32\\x1e.chromeos_update_engine.Extent\\x12\\x14\\n\\tfec_roots\\x18\\x10 \\x01(\\r:\\x01\\x32\\\"L\\n\\x15\\x44ynamicPartitionGroup\\x12\\x0c\\n\\x04name\\x18\\x01 \\x02(\\t\\x12\\x0c\\n\\x04size\\x18\\x02 \\x01(\\x04\\x12\\x17\\n\\x0fpartition_names\\x18\\x03 \\x03(\\t\\\"s\\n\\x18\\x44ynamicPartitionMetadata\\x12=\\n\\x06groups\\x18\\x01 \\x03(\\x0b\\x32-.chromeos_update_engine.DynamicPartitionGroup\\x12\\x18\\n\\x10snapshot_enabled\\x18\\x02 \\x01(\\x08\\\"\\xb1\\x06\\n\\x14\\x44\\x65ltaArchiveManifest\\x12\\x44\\n\\x12install_operations\\x18\\x01 \\x03(\\x0b\\x32(.chromeos_update_engine.InstallOperation\\x12K\\n\\x19kernel_install_operations\\x18\\x02 \\x03(\\x0b\\x32(.chromeos_update_engine.InstallOperation\\x12\\x18\\n\\nblock_size\\x18\\x03 \\x01(\\r:\\x04\\x34\\x30\\x39\\x36\\x12\\x19\\n\\x11signatures_offset\\x18\\x04 \\x01(\\x04\\x12\\x17\\n\\x0fsignatures_size\\x18\\x05 \\x01(\\x04\\x12>\\n\\x0fold_kernel_info\\x18\\x06 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12>\\n\\x0fnew_kernel_info\\x18\\x07 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12>\\n\\x0fold_rootfs_info\\x18\\x08 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12>\\n\\x0fnew_rootfs_info\\x18\\t \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12\\x39\\n\\x0eold_image_info\\x18\\n \\x01(\\x0b\\x32!.chromeos_update_engine.ImageInfo\\x12\\x39\\n\\x0enew_image_info\\x18\\x0b \\x01(\\x0b\\x32!.chromeos_update_engine.ImageInfo\\x12\\x18\\n\\rminor_version\\x18\\x0c \\x01(\\r:\\x01\\x30\\x12;\\n\\npartitions\\x18\\r \\x03(\\x0b\\x32\\'.chromeos_update_engine.PartitionUpdate\\x12\\x15\\n\\rmax_timestamp\\x18\\x0e \\x01(\\x03\\x12T\\n\\x1a\\x64ynamic_partition_metadata\\x18\\x0f \\x01(\\x0b\\x32\\x30.chromeos_update_engine.DynamicPartitionMetadataB\\x02H\\x03')\n)\n_INSTALLOPERATION_TYPE = _descriptor.EnumDescriptor(\n  name='Type',",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR = _descriptor.FileDescriptor(\n  name='update_metadata.proto',\n  package='chromeos_update_engine',\n  syntax='proto2',\n  serialized_options=_b('H\\003'),\n  serialized_pb=_b('\\n\\x15update_metadata.proto\\x12\\x16\\x63hromeos_update_engine\\\"1\\n\\x06\\x45xtent\\x12\\x13\\n\\x0bstart_block\\x18\\x01 \\x01(\\x04\\x12\\x12\\n\\nnum_blocks\\x18\\x02 \\x01(\\x04\\\"z\\n\\nSignatures\\x12@\\n\\nsignatures\\x18\\x01 \\x03(\\x0b\\x32,.chromeos_update_engine.Signatures.Signature\\x1a*\\n\\tSignature\\x12\\x0f\\n\\x07version\\x18\\x01 \\x01(\\r\\x12\\x0c\\n\\x04\\x64\\x61ta\\x18\\x02 \\x01(\\x0c\\\"+\\n\\rPartitionInfo\\x12\\x0c\\n\\x04size\\x18\\x01 \\x01(\\x04\\x12\\x0c\\n\\x04hash\\x18\\x02 \\x01(\\x0c\\\"w\\n\\tImageInfo\\x12\\r\\n\\x05\\x62oard\\x18\\x01 \\x01(\\t\\x12\\x0b\\n\\x03key\\x18\\x02 \\x01(\\t\\x12\\x0f\\n\\x07\\x63hannel\\x18\\x03 \\x01(\\t\\x12\\x0f\\n\\x07version\\x18\\x04 \\x01(\\t\\x12\\x15\\n\\rbuild_channel\\x18\\x05 \\x01(\\t\\x12\\x15\\n\\rbuild_version\\x18\\x06 \\x01(\\t\\\"\\xee\\x03\\n\\x10InstallOperation\\x12;\\n\\x04type\\x18\\x01 \\x02(\\x0e\\x32-.chromeos_update_engine.InstallOperation.Type\\x12\\x13\\n\\x0b\\x64\\x61ta_offset\\x18\\x02 \\x01(\\x04\\x12\\x13\\n\\x0b\\x64\\x61ta_length\\x18\\x03 \\x01(\\x04\\x12\\x33\\n\\x0bsrc_extents\\x18\\x04 \\x03(\\x0b\\x32\\x1e.chromeos_update_engine.Extent\\x12\\x12\\n\\nsrc_length\\x18\\x05 \\x01(\\x04\\x12\\x33\\n\\x0b\\x64st_extents\\x18\\x06 \\x03(\\x0b\\x32\\x1e.chromeos_update_engine.Extent\\x12\\x12\\n\\ndst_length\\x18\\x07 \\x01(\\x04\\x12\\x18\\n\\x10\\x64\\x61ta_sha256_hash\\x18\\x08 \\x01(\\x0c\\x12\\x17\\n\\x0fsrc_sha256_hash\\x18\\t \\x01(\\x0c\\\"\\xad\\x01\\n\\x04Type\\x12\\x0b\\n\\x07REPLACE\\x10\\x00\\x12\\x0e\\n\\nREPLACE_BZ\\x10\\x01\\x12\\x0c\\n\\x04MOVE\\x10\\x02\\x1a\\x02\\x08\\x01\\x12\\x0e\\n\\x06\\x42SDIFF\\x10\\x03\\x1a\\x02\\x08\\x01\\x12\\x0f\\n\\x0bSOURCE_COPY\\x10\\x04\\x12\\x11\\n\\rSOURCE_BSDIFF\\x10\\x05\\x12\\x0e\\n\\nREPLACE_XZ\\x10\\x08\\x12\\x08\\n\\x04ZERO\\x10\\x06\\x12\\x0b\\n\\x07\\x44ISCARD\\x10\\x07\\x12\\x11\\n\\rBROTLI_BSDIFF\\x10\\n\\x12\\x0c\\n\\x08PUFFDIFF\\x10\\t\\\"\\xd7\\x05\\n\\x0fPartitionUpdate\\x12\\x16\\n\\x0epartition_name\\x18\\x01 \\x02(\\t\\x12\\x17\\n\\x0frun_postinstall\\x18\\x02 \\x01(\\x08\\x12\\x18\\n\\x10postinstall_path\\x18\\x03 \\x01(\\t\\x12\\x17\\n\\x0f\\x66ilesystem_type\\x18\\x04 \\x01(\\t\\x12M\\n\\x17new_partition_signature\\x18\\x05 \\x03(\\x0b\\x32,.chromeos_update_engine.Signatures.Signature\\x12\\x41\\n\\x12old_partition_info\\x18\\x06 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12\\x41\\n\\x12new_partition_info\\x18\\x07 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12<\\n\\noperations\\x18\\x08 \\x03(\\x0b\\x32(.chromeos_update_engine.InstallOperation\\x12\\x1c\\n\\x14postinstall_optional\\x18\\t \\x01(\\x08\\x12=\\n\\x15hash_tree_data_extent\\x18\\n \\x01(\\x0b\\x32\\x1e.chromeos_update_engine.Extent\\x12\\x38\\n\\x10hash_tree_extent\\x18\\x0b \\x01(\\x0b\\x32\\x1e.chromeos_update_engine.Extent\\x12\\x1b\\n\\x13hash_tree_algorithm\\x18\\x0c \\x01(\\t\\x12\\x16\\n\\x0ehash_tree_salt\\x18\\r \\x01(\\x0c\\x12\\x37\\n\\x0f\\x66\\x65\\x63_data_extent\\x18\\x0e \\x01(\\x0b\\x32\\x1e.chromeos_update_engine.Extent\\x12\\x32\\n\\nfec_extent\\x18\\x0f \\x01(\\x0b\\x32\\x1e.chromeos_update_engine.Extent\\x12\\x14\\n\\tfec_roots\\x18\\x10 \\x01(\\r:\\x01\\x32\\\"L\\n\\x15\\x44ynamicPartitionGroup\\x12\\x0c\\n\\x04name\\x18\\x01 \\x02(\\t\\x12\\x0c\\n\\x04size\\x18\\x02 \\x01(\\x04\\x12\\x17\\n\\x0fpartition_names\\x18\\x03 \\x03(\\t\\\"s\\n\\x18\\x44ynamicPartitionMetadata\\x12=\\n\\x06groups\\x18\\x01 \\x03(\\x0b\\x32-.chromeos_update_engine.DynamicPartitionGroup\\x12\\x18\\n\\x10snapshot_enabled\\x18\\x02 \\x01(\\x08\\\"\\xb1\\x06\\n\\x14\\x44\\x65ltaArchiveManifest\\x12\\x44\\n\\x12install_operations\\x18\\x01 \\x03(\\x0b\\x32(.chromeos_update_engine.InstallOperation\\x12K\\n\\x19kernel_install_operations\\x18\\x02 \\x03(\\x0b\\x32(.chromeos_update_engine.InstallOperation\\x12\\x18\\n\\nblock_size\\x18\\x03 \\x01(\\r:\\x04\\x34\\x30\\x39\\x36\\x12\\x19\\n\\x11signatures_offset\\x18\\x04 \\x01(\\x04\\x12\\x17\\n\\x0fsignatures_size\\x18\\x05 \\x01(\\x04\\x12>\\n\\x0fold_kernel_info\\x18\\x06 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12>\\n\\x0fnew_kernel_info\\x18\\x07 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12>\\n\\x0fold_rootfs_info\\x18\\x08 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12>\\n\\x0fnew_rootfs_info\\x18\\t \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12\\x39\\n\\x0eold_image_info\\x18\\n \\x01(\\x0b\\x32!.chromeos_update_engine.ImageInfo\\x12\\x39\\n\\x0enew_image_info\\x18\\x0b \\x01(\\x0b\\x32!.chromeos_update_engine.ImageInfo\\x12\\x18\\n\\rminor_version\\x18\\x0c \\x01(\\r:\\x01\\x30\\x12;\\n\\npartitions\\x18\\r \\x03(\\x0b\\x32\\'.chromeos_update_engine.PartitionUpdate\\x12\\x15\\n\\rmax_timestamp\\x18\\x0e \\x01(\\x03\\x12T\\n\\x1a\\x64ynamic_partition_metadata\\x18\\x0f \\x01(\\x0b\\x32\\x30.chromeos_update_engine.DynamicPartitionMetadataB\\x02H\\x03')\n)\n_INSTALLOPERATION_TYPE = _descriptor.EnumDescriptor(\n  name='Type',\n  full_name='chromeos_update_engine.InstallOperation.Type',",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_INSTALLOPERATION_TYPE",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_INSTALLOPERATION_TYPE = _descriptor.EnumDescriptor(\n  name='Type',\n  full_name='chromeos_update_engine.InstallOperation.Type',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name='REPLACE', index=0, number=0,\n      serialized_options=None,\n      type=None),",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_EXTENT",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_EXTENT = _descriptor.Descriptor(\n  name='Extent',\n  full_name='chromeos_update_engine.Extent',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='start_block', full_name='chromeos_update_engine.Extent.start_block', index=0,\n      number=1, type=4, cpp_type=4, label=1,",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_SIGNATURES_SIGNATURE",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_SIGNATURES_SIGNATURE = _descriptor.Descriptor(\n  name='Signature',\n  full_name='chromeos_update_engine.Signatures.Signature',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='version', full_name='chromeos_update_engine.Signatures.Signature.version', index=0,\n      number=1, type=13, cpp_type=3, label=1,",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_SIGNATURES",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_SIGNATURES = _descriptor.Descriptor(\n  name='Signatures',\n  full_name='chromeos_update_engine.Signatures',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='signatures', full_name='chromeos_update_engine.Signatures.signatures', index=0,\n      number=1, type=11, cpp_type=10, label=3,",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_PARTITIONINFO",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_PARTITIONINFO = _descriptor.Descriptor(\n  name='PartitionInfo',\n  full_name='chromeos_update_engine.PartitionInfo',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='size', full_name='chromeos_update_engine.PartitionInfo.size', index=0,\n      number=1, type=4, cpp_type=4, label=1,",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_IMAGEINFO",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_IMAGEINFO = _descriptor.Descriptor(\n  name='ImageInfo',\n  full_name='chromeos_update_engine.ImageInfo',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='board', full_name='chromeos_update_engine.ImageInfo.board', index=0,\n      number=1, type=9, cpp_type=9, label=1,",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_INSTALLOPERATION",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_INSTALLOPERATION = _descriptor.Descriptor(\n  name='InstallOperation',\n  full_name='chromeos_update_engine.InstallOperation',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='type', full_name='chromeos_update_engine.InstallOperation.type', index=0,\n      number=1, type=14, cpp_type=8, label=2,",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_PARTITIONUPDATE",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_PARTITIONUPDATE = _descriptor.Descriptor(\n  name='PartitionUpdate',\n  full_name='chromeos_update_engine.PartitionUpdate',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='partition_name', full_name='chromeos_update_engine.PartitionUpdate.partition_name', index=0,\n      number=1, type=9, cpp_type=9, label=2,",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DYNAMICPARTITIONGROUP",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_DYNAMICPARTITIONGROUP = _descriptor.Descriptor(\n  name='DynamicPartitionGroup',\n  full_name='chromeos_update_engine.DynamicPartitionGroup',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='name', full_name='chromeos_update_engine.DynamicPartitionGroup.name', index=0,\n      number=1, type=9, cpp_type=9, label=2,",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DYNAMICPARTITIONMETADATA",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_DYNAMICPARTITIONMETADATA = _descriptor.Descriptor(\n  name='DynamicPartitionMetadata',\n  full_name='chromeos_update_engine.DynamicPartitionMetadata',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='groups', full_name='chromeos_update_engine.DynamicPartitionMetadata.groups', index=0,\n      number=1, type=11, cpp_type=10, label=3,",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST = _descriptor.Descriptor(\n  name='DeltaArchiveManifest',\n  full_name='chromeos_update_engine.DeltaArchiveManifest',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='install_operations', full_name='chromeos_update_engine.DeltaArchiveManifest.install_operations', index=0,\n      number=1, type=11, cpp_type=10, label=3,",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_SIGNATURES_SIGNATURE.containing_type",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_SIGNATURES_SIGNATURE.containing_type = _SIGNATURES\n_SIGNATURES.fields_by_name['signatures'].message_type = _SIGNATURES_SIGNATURE\n_INSTALLOPERATION.fields_by_name['type'].enum_type = _INSTALLOPERATION_TYPE\n_INSTALLOPERATION.fields_by_name['src_extents'].message_type = _EXTENT\n_INSTALLOPERATION.fields_by_name['dst_extents'].message_type = _EXTENT\n_INSTALLOPERATION_TYPE.containing_type = _INSTALLOPERATION\n_PARTITIONUPDATE.fields_by_name['new_partition_signature'].message_type = _SIGNATURES_SIGNATURE\n_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_SIGNATURES.fields_by_name['signatures'].message_type",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_SIGNATURES.fields_by_name['signatures'].message_type = _SIGNATURES_SIGNATURE\n_INSTALLOPERATION.fields_by_name['type'].enum_type = _INSTALLOPERATION_TYPE\n_INSTALLOPERATION.fields_by_name['src_extents'].message_type = _EXTENT\n_INSTALLOPERATION.fields_by_name['dst_extents'].message_type = _EXTENT\n_INSTALLOPERATION_TYPE.containing_type = _INSTALLOPERATION\n_PARTITIONUPDATE.fields_by_name['new_partition_signature'].message_type = _SIGNATURES_SIGNATURE\n_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION\n_PARTITIONUPDATE.fields_by_name['hash_tree_data_extent'].message_type = _EXTENT",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_INSTALLOPERATION.fields_by_name['type'].enum_type",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_INSTALLOPERATION.fields_by_name['type'].enum_type = _INSTALLOPERATION_TYPE\n_INSTALLOPERATION.fields_by_name['src_extents'].message_type = _EXTENT\n_INSTALLOPERATION.fields_by_name['dst_extents'].message_type = _EXTENT\n_INSTALLOPERATION_TYPE.containing_type = _INSTALLOPERATION\n_PARTITIONUPDATE.fields_by_name['new_partition_signature'].message_type = _SIGNATURES_SIGNATURE\n_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION\n_PARTITIONUPDATE.fields_by_name['hash_tree_data_extent'].message_type = _EXTENT\n_PARTITIONUPDATE.fields_by_name['hash_tree_extent'].message_type = _EXTENT",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_INSTALLOPERATION.fields_by_name['src_extents'].message_type",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_INSTALLOPERATION.fields_by_name['src_extents'].message_type = _EXTENT\n_INSTALLOPERATION.fields_by_name['dst_extents'].message_type = _EXTENT\n_INSTALLOPERATION_TYPE.containing_type = _INSTALLOPERATION\n_PARTITIONUPDATE.fields_by_name['new_partition_signature'].message_type = _SIGNATURES_SIGNATURE\n_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION\n_PARTITIONUPDATE.fields_by_name['hash_tree_data_extent'].message_type = _EXTENT\n_PARTITIONUPDATE.fields_by_name['hash_tree_extent'].message_type = _EXTENT\n_PARTITIONUPDATE.fields_by_name['fec_data_extent'].message_type = _EXTENT",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_INSTALLOPERATION.fields_by_name['dst_extents'].message_type",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_INSTALLOPERATION.fields_by_name['dst_extents'].message_type = _EXTENT\n_INSTALLOPERATION_TYPE.containing_type = _INSTALLOPERATION\n_PARTITIONUPDATE.fields_by_name['new_partition_signature'].message_type = _SIGNATURES_SIGNATURE\n_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION\n_PARTITIONUPDATE.fields_by_name['hash_tree_data_extent'].message_type = _EXTENT\n_PARTITIONUPDATE.fields_by_name['hash_tree_extent'].message_type = _EXTENT\n_PARTITIONUPDATE.fields_by_name['fec_data_extent'].message_type = _EXTENT\n_PARTITIONUPDATE.fields_by_name['fec_extent'].message_type = _EXTENT",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_INSTALLOPERATION_TYPE.containing_type",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_INSTALLOPERATION_TYPE.containing_type = _INSTALLOPERATION\n_PARTITIONUPDATE.fields_by_name['new_partition_signature'].message_type = _SIGNATURES_SIGNATURE\n_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION\n_PARTITIONUPDATE.fields_by_name['hash_tree_data_extent'].message_type = _EXTENT\n_PARTITIONUPDATE.fields_by_name['hash_tree_extent'].message_type = _EXTENT\n_PARTITIONUPDATE.fields_by_name['fec_data_extent'].message_type = _EXTENT\n_PARTITIONUPDATE.fields_by_name['fec_extent'].message_type = _EXTENT\n_DYNAMICPARTITIONMETADATA.fields_by_name['groups'].message_type = _DYNAMICPARTITIONGROUP",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_PARTITIONUPDATE.fields_by_name['new_partition_signature'].message_type",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_PARTITIONUPDATE.fields_by_name['new_partition_signature'].message_type = _SIGNATURES_SIGNATURE\n_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION\n_PARTITIONUPDATE.fields_by_name['hash_tree_data_extent'].message_type = _EXTENT\n_PARTITIONUPDATE.fields_by_name['hash_tree_extent'].message_type = _EXTENT\n_PARTITIONUPDATE.fields_by_name['fec_data_extent'].message_type = _EXTENT\n_PARTITIONUPDATE.fields_by_name['fec_extent'].message_type = _EXTENT\n_DYNAMICPARTITIONMETADATA.fields_by_name['groups'].message_type = _DYNAMICPARTITIONGROUP\n_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION\n_PARTITIONUPDATE.fields_by_name['hash_tree_data_extent'].message_type = _EXTENT\n_PARTITIONUPDATE.fields_by_name['hash_tree_extent'].message_type = _EXTENT\n_PARTITIONUPDATE.fields_by_name['fec_data_extent'].message_type = _EXTENT\n_PARTITIONUPDATE.fields_by_name['fec_extent'].message_type = _EXTENT\n_DYNAMICPARTITIONMETADATA.fields_by_name['groups'].message_type = _DYNAMICPARTITIONGROUP\n_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION\n_PARTITIONUPDATE.fields_by_name['hash_tree_data_extent'].message_type = _EXTENT\n_PARTITIONUPDATE.fields_by_name['hash_tree_extent'].message_type = _EXTENT\n_PARTITIONUPDATE.fields_by_name['fec_data_extent'].message_type = _EXTENT\n_PARTITIONUPDATE.fields_by_name['fec_extent'].message_type = _EXTENT\n_DYNAMICPARTITIONMETADATA.fields_by_name['groups'].message_type = _DYNAMICPARTITIONGROUP\n_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_PARTITIONUPDATE.fields_by_name['operations'].message_type",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION\n_PARTITIONUPDATE.fields_by_name['hash_tree_data_extent'].message_type = _EXTENT\n_PARTITIONUPDATE.fields_by_name['hash_tree_extent'].message_type = _EXTENT\n_PARTITIONUPDATE.fields_by_name['fec_data_extent'].message_type = _EXTENT\n_PARTITIONUPDATE.fields_by_name['fec_extent'].message_type = _EXTENT\n_DYNAMICPARTITIONMETADATA.fields_by_name['groups'].message_type = _DYNAMICPARTITIONGROUP\n_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_PARTITIONUPDATE.fields_by_name['hash_tree_data_extent'].message_type",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_PARTITIONUPDATE.fields_by_name['hash_tree_data_extent'].message_type = _EXTENT\n_PARTITIONUPDATE.fields_by_name['hash_tree_extent'].message_type = _EXTENT\n_PARTITIONUPDATE.fields_by_name['fec_data_extent'].message_type = _EXTENT\n_PARTITIONUPDATE.fields_by_name['fec_extent'].message_type = _EXTENT\n_DYNAMICPARTITIONMETADATA.fields_by_name['groups'].message_type = _DYNAMICPARTITIONGROUP\n_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_PARTITIONUPDATE.fields_by_name['hash_tree_extent'].message_type",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_PARTITIONUPDATE.fields_by_name['hash_tree_extent'].message_type = _EXTENT\n_PARTITIONUPDATE.fields_by_name['fec_data_extent'].message_type = _EXTENT\n_PARTITIONUPDATE.fields_by_name['fec_extent'].message_type = _EXTENT\n_DYNAMICPARTITIONMETADATA.fields_by_name['groups'].message_type = _DYNAMICPARTITIONGROUP\n_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_PARTITIONUPDATE.fields_by_name['fec_data_extent'].message_type",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_PARTITIONUPDATE.fields_by_name['fec_data_extent'].message_type = _EXTENT\n_PARTITIONUPDATE.fields_by_name['fec_extent'].message_type = _EXTENT\n_DYNAMICPARTITIONMETADATA.fields_by_name['groups'].message_type = _DYNAMICPARTITIONGROUP\n_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_PARTITIONUPDATE.fields_by_name['fec_extent'].message_type",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_PARTITIONUPDATE.fields_by_name['fec_extent'].message_type = _EXTENT\n_DYNAMICPARTITIONMETADATA.fields_by_name['groups'].message_type = _DYNAMICPARTITIONGROUP\n_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DYNAMICPARTITIONMETADATA.fields_by_name['groups'].message_type",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_DYNAMICPARTITIONMETADATA.fields_by_name['groups'].message_type = _DYNAMICPARTITIONGROUP\n_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE\n_DELTAARCHIVEMANIFEST.fields_by_name['dynamic_partition_metadata'].message_type = _DYNAMICPARTITIONMETADATA",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE\n_DELTAARCHIVEMANIFEST.fields_by_name['dynamic_partition_metadata'].message_type = _DYNAMICPARTITIONMETADATA\nDESCRIPTOR.message_types_by_name['Extent'] = _EXTENT",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE\n_DELTAARCHIVEMANIFEST.fields_by_name['dynamic_partition_metadata'].message_type = _DYNAMICPARTITIONMETADATA\nDESCRIPTOR.message_types_by_name['Extent'] = _EXTENT\nDESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE\n_DELTAARCHIVEMANIFEST.fields_by_name['dynamic_partition_metadata'].message_type = _DYNAMICPARTITIONMETADATA\nDESCRIPTOR.message_types_by_name['Extent'] = _EXTENT\nDESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES\nDESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE\n_DELTAARCHIVEMANIFEST.fields_by_name['dynamic_partition_metadata'].message_type = _DYNAMICPARTITIONMETADATA\nDESCRIPTOR.message_types_by_name['Extent'] = _EXTENT\nDESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES\nDESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO\nDESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE\n_DELTAARCHIVEMANIFEST.fields_by_name['dynamic_partition_metadata'].message_type = _DYNAMICPARTITIONMETADATA\nDESCRIPTOR.message_types_by_name['Extent'] = _EXTENT\nDESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES\nDESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO\nDESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO\nDESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE\n_DELTAARCHIVEMANIFEST.fields_by_name['dynamic_partition_metadata'].message_type = _DYNAMICPARTITIONMETADATA\nDESCRIPTOR.message_types_by_name['Extent'] = _EXTENT\nDESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES\nDESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO\nDESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO\nDESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION\nDESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE\n_DELTAARCHIVEMANIFEST.fields_by_name['dynamic_partition_metadata'].message_type = _DYNAMICPARTITIONMETADATA\nDESCRIPTOR.message_types_by_name['Extent'] = _EXTENT\nDESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES\nDESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO\nDESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO\nDESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION\nDESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['DynamicPartitionGroup'] = _DYNAMICPARTITIONGROUP",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE\n_DELTAARCHIVEMANIFEST.fields_by_name['dynamic_partition_metadata'].message_type = _DYNAMICPARTITIONMETADATA\nDESCRIPTOR.message_types_by_name['Extent'] = _EXTENT\nDESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES\nDESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO\nDESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO\nDESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION\nDESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['DynamicPartitionGroup'] = _DYNAMICPARTITIONGROUP\nDESCRIPTOR.message_types_by_name['DynamicPartitionMetadata'] = _DYNAMICPARTITIONMETADATA",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['dynamic_partition_metadata'].message_type",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['dynamic_partition_metadata'].message_type = _DYNAMICPARTITIONMETADATA\nDESCRIPTOR.message_types_by_name['Extent'] = _EXTENT\nDESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES\nDESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO\nDESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO\nDESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION\nDESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['DynamicPartitionGroup'] = _DYNAMICPARTITIONGROUP\nDESCRIPTOR.message_types_by_name['DynamicPartitionMetadata'] = _DYNAMICPARTITIONMETADATA\nDESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR.message_types_by_name['Extent']",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR.message_types_by_name['Extent'] = _EXTENT\nDESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES\nDESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO\nDESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO\nDESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION\nDESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['DynamicPartitionGroup'] = _DYNAMICPARTITIONGROUP\nDESCRIPTOR.message_types_by_name['DynamicPartitionMetadata'] = _DYNAMICPARTITIONMETADATA\nDESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR.message_types_by_name['Signatures']",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES\nDESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO\nDESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO\nDESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION\nDESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['DynamicPartitionGroup'] = _DYNAMICPARTITIONGROUP\nDESCRIPTOR.message_types_by_name['DynamicPartitionMetadata'] = _DYNAMICPARTITIONMETADATA\nDESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)\nExtent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), {",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR.message_types_by_name['PartitionInfo']",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO\nDESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO\nDESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION\nDESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['DynamicPartitionGroup'] = _DYNAMICPARTITIONGROUP\nDESCRIPTOR.message_types_by_name['DynamicPartitionMetadata'] = _DYNAMICPARTITIONMETADATA\nDESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)\nExtent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), {\n  'DESCRIPTOR' : _EXTENT,",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR.message_types_by_name['ImageInfo']",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO\nDESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION\nDESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['DynamicPartitionGroup'] = _DYNAMICPARTITIONGROUP\nDESCRIPTOR.message_types_by_name['DynamicPartitionMetadata'] = _DYNAMICPARTITIONMETADATA\nDESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)\nExtent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), {\n  'DESCRIPTOR' : _EXTENT,\n  '__module__' : 'update_metadata_pb2'",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR.message_types_by_name['InstallOperation']",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION\nDESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['DynamicPartitionGroup'] = _DYNAMICPARTITIONGROUP\nDESCRIPTOR.message_types_by_name['DynamicPartitionMetadata'] = _DYNAMICPARTITIONMETADATA\nDESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)\nExtent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), {\n  'DESCRIPTOR' : _EXTENT,\n  '__module__' : 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.Extent)",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR.message_types_by_name['PartitionUpdate']",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['DynamicPartitionGroup'] = _DYNAMICPARTITIONGROUP\nDESCRIPTOR.message_types_by_name['DynamicPartitionMetadata'] = _DYNAMICPARTITIONMETADATA\nDESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)\nExtent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), {\n  'DESCRIPTOR' : _EXTENT,\n  '__module__' : 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.Extent)\n  })",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR.message_types_by_name['DynamicPartitionGroup']",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR.message_types_by_name['DynamicPartitionGroup'] = _DYNAMICPARTITIONGROUP\nDESCRIPTOR.message_types_by_name['DynamicPartitionMetadata'] = _DYNAMICPARTITIONMETADATA\nDESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)\nExtent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), {\n  'DESCRIPTOR' : _EXTENT,\n  '__module__' : 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.Extent)\n  })\n_sym_db.RegisterMessage(Extent)",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR.message_types_by_name['DynamicPartitionMetadata']",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR.message_types_by_name['DynamicPartitionMetadata'] = _DYNAMICPARTITIONMETADATA\nDESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)\nExtent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), {\n  'DESCRIPTOR' : _EXTENT,\n  '__module__' : 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.Extent)\n  })\n_sym_db.RegisterMessage(Extent)\nSignatures = _reflection.GeneratedProtocolMessageType('Signatures', (_message.Message,), {",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR.message_types_by_name['DeltaArchiveManifest']",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)\nExtent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), {\n  'DESCRIPTOR' : _EXTENT,\n  '__module__' : 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.Extent)\n  })\n_sym_db.RegisterMessage(Extent)\nSignatures = _reflection.GeneratedProtocolMessageType('Signatures', (_message.Message,), {\n  'Signature' : _reflection.GeneratedProtocolMessageType('Signature', (_message.Message,), {",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "Extent",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "Extent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), {\n  'DESCRIPTOR' : _EXTENT,\n  '__module__' : 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.Extent)\n  })\n_sym_db.RegisterMessage(Extent)\nSignatures = _reflection.GeneratedProtocolMessageType('Signatures', (_message.Message,), {\n  'Signature' : _reflection.GeneratedProtocolMessageType('Signature', (_message.Message,), {\n    'DESCRIPTOR' : _SIGNATURES_SIGNATURE,\n    '__module__' : 'update_metadata_pb2'",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "Signatures",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "Signatures = _reflection.GeneratedProtocolMessageType('Signatures', (_message.Message,), {\n  'Signature' : _reflection.GeneratedProtocolMessageType('Signature', (_message.Message,), {\n    'DESCRIPTOR' : _SIGNATURES_SIGNATURE,\n    '__module__' : 'update_metadata_pb2'\n    # @@protoc_insertion_point(class_scope:chromeos_update_engine.Signatures.Signature)\n    })\n  ,\n  'DESCRIPTOR' : _SIGNATURES,\n  '__module__' : 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.Signatures)",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "PartitionInfo",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "PartitionInfo = _reflection.GeneratedProtocolMessageType('PartitionInfo', (_message.Message,), {\n  'DESCRIPTOR' : _PARTITIONINFO,\n  '__module__' : 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.PartitionInfo)\n  })\n_sym_db.RegisterMessage(PartitionInfo)\nImageInfo = _reflection.GeneratedProtocolMessageType('ImageInfo', (_message.Message,), {\n  'DESCRIPTOR' : _IMAGEINFO,\n  '__module__' : 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.ImageInfo)",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "ImageInfo",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "ImageInfo = _reflection.GeneratedProtocolMessageType('ImageInfo', (_message.Message,), {\n  'DESCRIPTOR' : _IMAGEINFO,\n  '__module__' : 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.ImageInfo)\n  })\n_sym_db.RegisterMessage(ImageInfo)\nInstallOperation = _reflection.GeneratedProtocolMessageType('InstallOperation', (_message.Message,), {\n  'DESCRIPTOR' : _INSTALLOPERATION,\n  '__module__' : 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.InstallOperation)",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "InstallOperation",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "InstallOperation = _reflection.GeneratedProtocolMessageType('InstallOperation', (_message.Message,), {\n  'DESCRIPTOR' : _INSTALLOPERATION,\n  '__module__' : 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.InstallOperation)\n  })\n_sym_db.RegisterMessage(InstallOperation)\nPartitionUpdate = _reflection.GeneratedProtocolMessageType('PartitionUpdate', (_message.Message,), {\n  'DESCRIPTOR' : _PARTITIONUPDATE,\n  '__module__' : 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.PartitionUpdate)",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "PartitionUpdate",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "PartitionUpdate = _reflection.GeneratedProtocolMessageType('PartitionUpdate', (_message.Message,), {\n  'DESCRIPTOR' : _PARTITIONUPDATE,\n  '__module__' : 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.PartitionUpdate)\n  })\n_sym_db.RegisterMessage(PartitionUpdate)\nDynamicPartitionGroup = _reflection.GeneratedProtocolMessageType('DynamicPartitionGroup', (_message.Message,), {\n  'DESCRIPTOR' : _DYNAMICPARTITIONGROUP,\n  '__module__' : 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.DynamicPartitionGroup)",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DynamicPartitionGroup",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "DynamicPartitionGroup = _reflection.GeneratedProtocolMessageType('DynamicPartitionGroup', (_message.Message,), {\n  'DESCRIPTOR' : _DYNAMICPARTITIONGROUP,\n  '__module__' : 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.DynamicPartitionGroup)\n  })\n_sym_db.RegisterMessage(DynamicPartitionGroup)\nDynamicPartitionMetadata = _reflection.GeneratedProtocolMessageType('DynamicPartitionMetadata', (_message.Message,), {\n  'DESCRIPTOR' : _DYNAMICPARTITIONMETADATA,\n  '__module__' : 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.DynamicPartitionMetadata)",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DynamicPartitionMetadata",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "DynamicPartitionMetadata = _reflection.GeneratedProtocolMessageType('DynamicPartitionMetadata', (_message.Message,), {\n  'DESCRIPTOR' : _DYNAMICPARTITIONMETADATA,\n  '__module__' : 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.DynamicPartitionMetadata)\n  })\n_sym_db.RegisterMessage(DynamicPartitionMetadata)\nDeltaArchiveManifest = _reflection.GeneratedProtocolMessageType('DeltaArchiveManifest', (_message.Message,), {\n  'DESCRIPTOR' : _DELTAARCHIVEMANIFEST,\n  '__module__' : 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.DeltaArchiveManifest)",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DeltaArchiveManifest",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "DeltaArchiveManifest = _reflection.GeneratedProtocolMessageType('DeltaArchiveManifest', (_message.Message,), {\n  'DESCRIPTOR' : _DELTAARCHIVEMANIFEST,\n  '__module__' : 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.DeltaArchiveManifest)\n  })\n_sym_db.RegisterMessage(DeltaArchiveManifest)\nDESCRIPTOR._options = None\n_INSTALLOPERATION_TYPE.values_by_name[\"MOVE\"]._options = None\n_INSTALLOPERATION_TYPE.values_by_name[\"BSDIFF\"]._options = None\n# @@protoc_insertion_point(module_scope)",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR._options",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR._options = None\n_INSTALLOPERATION_TYPE.values_by_name[\"MOVE\"]._options = None\n_INSTALLOPERATION_TYPE.values_by_name[\"BSDIFF\"]._options = None\n# @@protoc_insertion_point(module_scope)",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_INSTALLOPERATION_TYPE.values_by_name[\"MOVE\"]._options",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_INSTALLOPERATION_TYPE.values_by_name[\"MOVE\"]._options = None\n_INSTALLOPERATION_TYPE.values_by_name[\"BSDIFF\"]._options = None\n# @@protoc_insertion_point(module_scope)",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_INSTALLOPERATION_TYPE.values_by_name[\"BSDIFF\"]._options",
        "kind": 5,
        "importPath": "bin_payload.extract_payload-master.update_metadata_pb2",
        "description": "bin_payload.extract_payload-master.update_metadata_pb2",
        "peekOfCode": "_INSTALLOPERATION_TYPE.values_by_name[\"BSDIFF\"]._options = None\n# @@protoc_insertion_point(module_scope)",
        "detail": "bin_payload.extract_payload-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "u32",
        "kind": 2,
        "importPath": "bin_payload.payload_dumper-master.payload_dumper",
        "description": "bin_payload.payload_dumper-master.payload_dumper",
        "peekOfCode": "def u32(x):\n    return struct.unpack('>I', x)[0]\ndef u64(x):\n    return struct.unpack('>Q', x)[0]\ndef verify_contiguous(exts):\n    blocks = 0\n    for ext in exts:\n        if ext.start_block != blocks:\n            return False\n        blocks += ext.num_blocks",
        "detail": "bin_payload.payload_dumper-master.payload_dumper",
        "documentation": {}
    },
    {
        "label": "u64",
        "kind": 2,
        "importPath": "bin_payload.payload_dumper-master.payload_dumper",
        "description": "bin_payload.payload_dumper-master.payload_dumper",
        "peekOfCode": "def u64(x):\n    return struct.unpack('>Q', x)[0]\ndef verify_contiguous(exts):\n    blocks = 0\n    for ext in exts:\n        if ext.start_block != blocks:\n            return False\n        blocks += ext.num_blocks\n    return True\ndef data_for_op(op,out_file,old_file):",
        "detail": "bin_payload.payload_dumper-master.payload_dumper",
        "documentation": {}
    },
    {
        "label": "verify_contiguous",
        "kind": 2,
        "importPath": "bin_payload.payload_dumper-master.payload_dumper",
        "description": "bin_payload.payload_dumper-master.payload_dumper",
        "peekOfCode": "def verify_contiguous(exts):\n    blocks = 0\n    for ext in exts:\n        if ext.start_block != blocks:\n            return False\n        blocks += ext.num_blocks\n    return True\ndef data_for_op(op,out_file,old_file):\n    args.payloadfile.seek(data_offset + op.data_offset)\n    data = args.payloadfile.read(op.data_length)",
        "detail": "bin_payload.payload_dumper-master.payload_dumper",
        "documentation": {}
    },
    {
        "label": "data_for_op",
        "kind": 2,
        "importPath": "bin_payload.payload_dumper-master.payload_dumper",
        "description": "bin_payload.payload_dumper-master.payload_dumper",
        "peekOfCode": "def data_for_op(op,out_file,old_file):\n    args.payloadfile.seek(data_offset + op.data_offset)\n    data = args.payloadfile.read(op.data_length)\n    # assert hashlib.sha256(data).digest() == op.data_sha256_hash, 'operation data hash mismatch'\n    if op.type == op.REPLACE_XZ:\n        dec = lzma.LZMADecompressor()\n        data = dec.decompress(data)\n        out_file.seek(op.dst_extents[0].start_block*block_size)\n        out_file.write(data)\n    elif op.type == op.REPLACE_BZ:",
        "detail": "bin_payload.payload_dumper-master.payload_dumper",
        "documentation": {}
    },
    {
        "label": "dump_part",
        "kind": 2,
        "importPath": "bin_payload.payload_dumper-master.payload_dumper",
        "description": "bin_payload.payload_dumper-master.payload_dumper",
        "peekOfCode": "def dump_part(part):\n    sys.stdout.write(\"Processing %s partition\" % part.partition_name)\n    sys.stdout.flush()\n    out_file = open('%s/%s.img' % (args.out, part.partition_name), 'wb')\n    h = hashlib.sha256()\n    if args.diff:\n        old_file = open('%s/%s.img' % (args.old, part.partition_name), 'rb')\n    else:\n        old_file = None\n    for op in part.operations:",
        "detail": "bin_payload.payload_dumper-master.payload_dumper",
        "documentation": {}
    },
    {
        "label": "flatten",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.payload_dumper",
        "description": "bin_payload.payload_dumper-master.payload_dumper",
        "peekOfCode": "flatten = lambda l: [item for sublist in l for item in sublist]\ndef u32(x):\n    return struct.unpack('>I', x)[0]\ndef u64(x):\n    return struct.unpack('>Q', x)[0]\ndef verify_contiguous(exts):\n    blocks = 0\n    for ext in exts:\n        if ext.start_block != blocks:\n            return False",
        "detail": "bin_payload.payload_dumper-master.payload_dumper",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.payload_dumper",
        "description": "bin_payload.payload_dumper-master.payload_dumper",
        "peekOfCode": "parser = argparse.ArgumentParser(description='OTA payload dumper')\nparser.add_argument('payloadfile', type=argparse.FileType('rb'), \n                    help='payload file name')\nparser.add_argument('--out', default='output',\n                    help='output directory (defaul: output)')\nparser.add_argument('--diff',action='store_true',\n                    help='extract differential OTA, you need put original images to old dir')\nparser.add_argument('--old', default='old',\n                    help='directory with original images for differential OTA (defaul: old)')\nargs = parser.parse_args()",
        "detail": "bin_payload.payload_dumper-master.payload_dumper",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.payload_dumper",
        "description": "bin_payload.payload_dumper-master.payload_dumper",
        "peekOfCode": "args = parser.parse_args()\nmagic = args.payloadfile.read(4)\nassert magic == b'CrAU'\nfile_format_version = u64(args.payloadfile.read(8))\nassert file_format_version == 2\nmanifest_size = u64(args.payloadfile.read(8))\nmetadata_signature_size = 0\nif file_format_version > 1:\n    metadata_signature_size = u32(args.payloadfile.read(4))\nmanifest = args.payloadfile.read(manifest_size)",
        "detail": "bin_payload.payload_dumper-master.payload_dumper",
        "documentation": {}
    },
    {
        "label": "magic",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.payload_dumper",
        "description": "bin_payload.payload_dumper-master.payload_dumper",
        "peekOfCode": "magic = args.payloadfile.read(4)\nassert magic == b'CrAU'\nfile_format_version = u64(args.payloadfile.read(8))\nassert file_format_version == 2\nmanifest_size = u64(args.payloadfile.read(8))\nmetadata_signature_size = 0\nif file_format_version > 1:\n    metadata_signature_size = u32(args.payloadfile.read(4))\nmanifest = args.payloadfile.read(manifest_size)\nmetadata_signature = args.payloadfile.read(metadata_signature_size)",
        "detail": "bin_payload.payload_dumper-master.payload_dumper",
        "documentation": {}
    },
    {
        "label": "file_format_version",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.payload_dumper",
        "description": "bin_payload.payload_dumper-master.payload_dumper",
        "peekOfCode": "file_format_version = u64(args.payloadfile.read(8))\nassert file_format_version == 2\nmanifest_size = u64(args.payloadfile.read(8))\nmetadata_signature_size = 0\nif file_format_version > 1:\n    metadata_signature_size = u32(args.payloadfile.read(4))\nmanifest = args.payloadfile.read(manifest_size)\nmetadata_signature = args.payloadfile.read(metadata_signature_size)\ndata_offset = args.payloadfile.tell()\ndam = um.DeltaArchiveManifest()",
        "detail": "bin_payload.payload_dumper-master.payload_dumper",
        "documentation": {}
    },
    {
        "label": "manifest_size",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.payload_dumper",
        "description": "bin_payload.payload_dumper-master.payload_dumper",
        "peekOfCode": "manifest_size = u64(args.payloadfile.read(8))\nmetadata_signature_size = 0\nif file_format_version > 1:\n    metadata_signature_size = u32(args.payloadfile.read(4))\nmanifest = args.payloadfile.read(manifest_size)\nmetadata_signature = args.payloadfile.read(metadata_signature_size)\ndata_offset = args.payloadfile.tell()\ndam = um.DeltaArchiveManifest()\ndam.ParseFromString(manifest)\nblock_size = dam.block_size",
        "detail": "bin_payload.payload_dumper-master.payload_dumper",
        "documentation": {}
    },
    {
        "label": "metadata_signature_size",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.payload_dumper",
        "description": "bin_payload.payload_dumper-master.payload_dumper",
        "peekOfCode": "metadata_signature_size = 0\nif file_format_version > 1:\n    metadata_signature_size = u32(args.payloadfile.read(4))\nmanifest = args.payloadfile.read(manifest_size)\nmetadata_signature = args.payloadfile.read(metadata_signature_size)\ndata_offset = args.payloadfile.tell()\ndam = um.DeltaArchiveManifest()\ndam.ParseFromString(manifest)\nblock_size = dam.block_size\nfor part in dam.partitions:",
        "detail": "bin_payload.payload_dumper-master.payload_dumper",
        "documentation": {}
    },
    {
        "label": "manifest",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.payload_dumper",
        "description": "bin_payload.payload_dumper-master.payload_dumper",
        "peekOfCode": "manifest = args.payloadfile.read(manifest_size)\nmetadata_signature = args.payloadfile.read(metadata_signature_size)\ndata_offset = args.payloadfile.tell()\ndam = um.DeltaArchiveManifest()\ndam.ParseFromString(manifest)\nblock_size = dam.block_size\nfor part in dam.partitions:\n    # for op in part.operations:\n    #     assert op.type in (op.REPLACE, op.REPLACE_BZ, op.REPLACE_XZ), \\\n    #             'unsupported op'",
        "detail": "bin_payload.payload_dumper-master.payload_dumper",
        "documentation": {}
    },
    {
        "label": "metadata_signature",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.payload_dumper",
        "description": "bin_payload.payload_dumper-master.payload_dumper",
        "peekOfCode": "metadata_signature = args.payloadfile.read(metadata_signature_size)\ndata_offset = args.payloadfile.tell()\ndam = um.DeltaArchiveManifest()\ndam.ParseFromString(manifest)\nblock_size = dam.block_size\nfor part in dam.partitions:\n    # for op in part.operations:\n    #     assert op.type in (op.REPLACE, op.REPLACE_BZ, op.REPLACE_XZ), \\\n    #             'unsupported op'\n    # extents = flatten([op.dst_extents for op in part.operations])",
        "detail": "bin_payload.payload_dumper-master.payload_dumper",
        "documentation": {}
    },
    {
        "label": "data_offset",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.payload_dumper",
        "description": "bin_payload.payload_dumper-master.payload_dumper",
        "peekOfCode": "data_offset = args.payloadfile.tell()\ndam = um.DeltaArchiveManifest()\ndam.ParseFromString(manifest)\nblock_size = dam.block_size\nfor part in dam.partitions:\n    # for op in part.operations:\n    #     assert op.type in (op.REPLACE, op.REPLACE_BZ, op.REPLACE_XZ), \\\n    #             'unsupported op'\n    # extents = flatten([op.dst_extents for op in part.operations])\n    # assert verify_contiguous(extents), 'operations do not span full image'",
        "detail": "bin_payload.payload_dumper-master.payload_dumper",
        "documentation": {}
    },
    {
        "label": "dam",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.payload_dumper",
        "description": "bin_payload.payload_dumper-master.payload_dumper",
        "peekOfCode": "dam = um.DeltaArchiveManifest()\ndam.ParseFromString(manifest)\nblock_size = dam.block_size\nfor part in dam.partitions:\n    # for op in part.operations:\n    #     assert op.type in (op.REPLACE, op.REPLACE_BZ, op.REPLACE_XZ), \\\n    #             'unsupported op'\n    # extents = flatten([op.dst_extents for op in part.operations])\n    # assert verify_contiguous(extents), 'operations do not span full image'\n    dump_part(part)",
        "detail": "bin_payload.payload_dumper-master.payload_dumper",
        "documentation": {}
    },
    {
        "label": "block_size",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.payload_dumper",
        "description": "bin_payload.payload_dumper-master.payload_dumper",
        "peekOfCode": "block_size = dam.block_size\nfor part in dam.partitions:\n    # for op in part.operations:\n    #     assert op.type in (op.REPLACE, op.REPLACE_BZ, op.REPLACE_XZ), \\\n    #             'unsupported op'\n    # extents = flatten([op.dst_extents for op in part.operations])\n    # assert verify_contiguous(extents), 'operations do not span full image'\n    dump_part(part)",
        "detail": "bin_payload.payload_dumper-master.payload_dumper",
        "documentation": {}
    },
    {
        "label": "_sym_db",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_sym_db = _symbol_database.Default()\nDESCRIPTOR = _descriptor.FileDescriptor(\n  name='update_metadata.proto',\n  package='chromeos_update_engine',\n  syntax='proto2',\n  serialized_pb=_b('\\n\\x15update_metadata.proto\\x12\\x16\\x63hromeos_update_engine\\\"1\\n\\x06\\x45xtent\\x12\\x13\\n\\x0bstart_block\\x18\\x01 \\x01(\\x04\\x12\\x12\\n\\nnum_blocks\\x18\\x02 \\x01(\\x04\\\"z\\n\\nSignatures\\x12@\\n\\nsignatures\\x18\\x01 \\x03(\\x0b\\x32,.chromeos_update_engine.Signatures.Signature\\x1a*\\n\\tSignature\\x12\\x0f\\n\\x07version\\x18\\x01 \\x01(\\r\\x12\\x0c\\n\\x04\\x64\\x61ta\\x18\\x02 \\x01(\\x0c\\\"+\\n\\rPartitionInfo\\x12\\x0c\\n\\x04size\\x18\\x01 \\x01(\\x04\\x12\\x0c\\n\\x04hash\\x18\\x02 \\x01(\\x0c\\\"w\\n\\tImageInfo\\x12\\r\\n\\x05\\x62oard\\x18\\x01 \\x01(\\t\\x12\\x0b\\n\\x03key\\x18\\x02 \\x01(\\t\\x12\\x0f\\n\\x07\\x63hannel\\x18\\x03 \\x01(\\t\\x12\\x0f\\n\\x07version\\x18\\x04 \\x01(\\t\\x12\\x15\\n\\rbuild_channel\\x18\\x05 \\x01(\\t\\x12\\x15\\n\\rbuild_version\\x18\\x06 \\x01(\\t\\\"\\xd3\\x03\\n\\x10InstallOperation\\x12;\\n\\x04type\\x18\\x01 \\x02(\\x0e\\x32-.chromeos_update_engine.InstallOperation.Type\\x12\\x13\\n\\x0b\\x64\\x61ta_offset\\x18\\x02 \\x01(\\r\\x12\\x13\\n\\x0b\\x64\\x61ta_length\\x18\\x03 \\x01(\\r\\x12\\x33\\n\\x0bsrc_extents\\x18\\x04 \\x03(\\x0b\\x32\\x1e.chromeos_update_engine.Extent\\x12\\x12\\n\\nsrc_length\\x18\\x05 \\x01(\\x04\\x12\\x33\\n\\x0b\\x64st_extents\\x18\\x06 \\x03(\\x0b\\x32\\x1e.chromeos_update_engine.Extent\\x12\\x12\\n\\ndst_length\\x18\\x07 \\x01(\\x04\\x12\\x18\\n\\x10\\x64\\x61ta_sha256_hash\\x18\\x08 \\x01(\\x0c\\x12\\x17\\n\\x0fsrc_sha256_hash\\x18\\t \\x01(\\x0c\\\"\\x92\\x01\\n\\x04Type\\x12\\x0b\\n\\x07REPLACE\\x10\\x00\\x12\\x0e\\n\\nREPLACE_BZ\\x10\\x01\\x12\\x08\\n\\x04MOVE\\x10\\x02\\x12\\n\\n\\x06\\x42SDIFF\\x10\\x03\\x12\\x0f\\n\\x0bSOURCE_COPY\\x10\\x04\\x12\\x11\\n\\rSOURCE_BSDIFF\\x10\\x05\\x12\\x08\\n\\x04ZERO\\x10\\x06\\x12\\x0b\\n\\x07\\x44ISCARD\\x10\\x07\\x12\\x0e\\n\\nREPLACE_XZ\\x10\\x08\\x12\\x0c\\n\\x08PUFFDIFF\\x10\\t\\\"\\xa6\\x03\\n\\x0fPartitionUpdate\\x12\\x16\\n\\x0epartition_name\\x18\\x01 \\x02(\\t\\x12\\x17\\n\\x0frun_postinstall\\x18\\x02 \\x01(\\x08\\x12\\x18\\n\\x10postinstall_path\\x18\\x03 \\x01(\\t\\x12\\x17\\n\\x0f\\x66ilesystem_type\\x18\\x04 \\x01(\\t\\x12M\\n\\x17new_partition_signature\\x18\\x05 \\x03(\\x0b\\x32,.chromeos_update_engine.Signatures.Signature\\x12\\x41\\n\\x12old_partition_info\\x18\\x06 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12\\x41\\n\\x12new_partition_info\\x18\\x07 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12<\\n\\noperations\\x18\\x08 \\x03(\\x0b\\x32(.chromeos_update_engine.InstallOperation\\x12\\x1c\\n\\x14postinstall_optional\\x18\\t \\x01(\\x08\\\"\\xc4\\x05\\n\\x14\\x44\\x65ltaArchiveManifest\\x12\\x44\\n\\x12install_operations\\x18\\x01 \\x03(\\x0b\\x32(.chromeos_update_engine.InstallOperation\\x12K\\n\\x19kernel_install_operations\\x18\\x02 \\x03(\\x0b\\x32(.chromeos_update_engine.InstallOperation\\x12\\x18\\n\\nblock_size\\x18\\x03 \\x01(\\r:\\x04\\x34\\x30\\x39\\x36\\x12\\x19\\n\\x11signatures_offset\\x18\\x04 \\x01(\\x04\\x12\\x17\\n\\x0fsignatures_size\\x18\\x05 \\x01(\\x04\\x12>\\n\\x0fold_kernel_info\\x18\\x06 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12>\\n\\x0fnew_kernel_info\\x18\\x07 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12>\\n\\x0fold_rootfs_info\\x18\\x08 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12>\\n\\x0fnew_rootfs_info\\x18\\t \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12\\x39\\n\\x0eold_image_info\\x18\\n \\x01(\\x0b\\x32!.chromeos_update_engine.ImageInfo\\x12\\x39\\n\\x0enew_image_info\\x18\\x0b \\x01(\\x0b\\x32!.chromeos_update_engine.ImageInfo\\x12\\x18\\n\\rminor_version\\x18\\x0c \\x01(\\r:\\x01\\x30\\x12;\\n\\npartitions\\x18\\r \\x03(\\x0b\\x32\\'.chromeos_update_engine.PartitionUpdateB\\x02H\\x03')\n)\n_INSTALLOPERATION_TYPE = _descriptor.EnumDescriptor(\n  name='Type',\n  full_name='chromeos_update_engine.InstallOperation.Type',",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR = _descriptor.FileDescriptor(\n  name='update_metadata.proto',\n  package='chromeos_update_engine',\n  syntax='proto2',\n  serialized_pb=_b('\\n\\x15update_metadata.proto\\x12\\x16\\x63hromeos_update_engine\\\"1\\n\\x06\\x45xtent\\x12\\x13\\n\\x0bstart_block\\x18\\x01 \\x01(\\x04\\x12\\x12\\n\\nnum_blocks\\x18\\x02 \\x01(\\x04\\\"z\\n\\nSignatures\\x12@\\n\\nsignatures\\x18\\x01 \\x03(\\x0b\\x32,.chromeos_update_engine.Signatures.Signature\\x1a*\\n\\tSignature\\x12\\x0f\\n\\x07version\\x18\\x01 \\x01(\\r\\x12\\x0c\\n\\x04\\x64\\x61ta\\x18\\x02 \\x01(\\x0c\\\"+\\n\\rPartitionInfo\\x12\\x0c\\n\\x04size\\x18\\x01 \\x01(\\x04\\x12\\x0c\\n\\x04hash\\x18\\x02 \\x01(\\x0c\\\"w\\n\\tImageInfo\\x12\\r\\n\\x05\\x62oard\\x18\\x01 \\x01(\\t\\x12\\x0b\\n\\x03key\\x18\\x02 \\x01(\\t\\x12\\x0f\\n\\x07\\x63hannel\\x18\\x03 \\x01(\\t\\x12\\x0f\\n\\x07version\\x18\\x04 \\x01(\\t\\x12\\x15\\n\\rbuild_channel\\x18\\x05 \\x01(\\t\\x12\\x15\\n\\rbuild_version\\x18\\x06 \\x01(\\t\\\"\\xd3\\x03\\n\\x10InstallOperation\\x12;\\n\\x04type\\x18\\x01 \\x02(\\x0e\\x32-.chromeos_update_engine.InstallOperation.Type\\x12\\x13\\n\\x0b\\x64\\x61ta_offset\\x18\\x02 \\x01(\\r\\x12\\x13\\n\\x0b\\x64\\x61ta_length\\x18\\x03 \\x01(\\r\\x12\\x33\\n\\x0bsrc_extents\\x18\\x04 \\x03(\\x0b\\x32\\x1e.chromeos_update_engine.Extent\\x12\\x12\\n\\nsrc_length\\x18\\x05 \\x01(\\x04\\x12\\x33\\n\\x0b\\x64st_extents\\x18\\x06 \\x03(\\x0b\\x32\\x1e.chromeos_update_engine.Extent\\x12\\x12\\n\\ndst_length\\x18\\x07 \\x01(\\x04\\x12\\x18\\n\\x10\\x64\\x61ta_sha256_hash\\x18\\x08 \\x01(\\x0c\\x12\\x17\\n\\x0fsrc_sha256_hash\\x18\\t \\x01(\\x0c\\\"\\x92\\x01\\n\\x04Type\\x12\\x0b\\n\\x07REPLACE\\x10\\x00\\x12\\x0e\\n\\nREPLACE_BZ\\x10\\x01\\x12\\x08\\n\\x04MOVE\\x10\\x02\\x12\\n\\n\\x06\\x42SDIFF\\x10\\x03\\x12\\x0f\\n\\x0bSOURCE_COPY\\x10\\x04\\x12\\x11\\n\\rSOURCE_BSDIFF\\x10\\x05\\x12\\x08\\n\\x04ZERO\\x10\\x06\\x12\\x0b\\n\\x07\\x44ISCARD\\x10\\x07\\x12\\x0e\\n\\nREPLACE_XZ\\x10\\x08\\x12\\x0c\\n\\x08PUFFDIFF\\x10\\t\\\"\\xa6\\x03\\n\\x0fPartitionUpdate\\x12\\x16\\n\\x0epartition_name\\x18\\x01 \\x02(\\t\\x12\\x17\\n\\x0frun_postinstall\\x18\\x02 \\x01(\\x08\\x12\\x18\\n\\x10postinstall_path\\x18\\x03 \\x01(\\t\\x12\\x17\\n\\x0f\\x66ilesystem_type\\x18\\x04 \\x01(\\t\\x12M\\n\\x17new_partition_signature\\x18\\x05 \\x03(\\x0b\\x32,.chromeos_update_engine.Signatures.Signature\\x12\\x41\\n\\x12old_partition_info\\x18\\x06 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12\\x41\\n\\x12new_partition_info\\x18\\x07 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12<\\n\\noperations\\x18\\x08 \\x03(\\x0b\\x32(.chromeos_update_engine.InstallOperation\\x12\\x1c\\n\\x14postinstall_optional\\x18\\t \\x01(\\x08\\\"\\xc4\\x05\\n\\x14\\x44\\x65ltaArchiveManifest\\x12\\x44\\n\\x12install_operations\\x18\\x01 \\x03(\\x0b\\x32(.chromeos_update_engine.InstallOperation\\x12K\\n\\x19kernel_install_operations\\x18\\x02 \\x03(\\x0b\\x32(.chromeos_update_engine.InstallOperation\\x12\\x18\\n\\nblock_size\\x18\\x03 \\x01(\\r:\\x04\\x34\\x30\\x39\\x36\\x12\\x19\\n\\x11signatures_offset\\x18\\x04 \\x01(\\x04\\x12\\x17\\n\\x0fsignatures_size\\x18\\x05 \\x01(\\x04\\x12>\\n\\x0fold_kernel_info\\x18\\x06 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12>\\n\\x0fnew_kernel_info\\x18\\x07 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12>\\n\\x0fold_rootfs_info\\x18\\x08 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12>\\n\\x0fnew_rootfs_info\\x18\\t \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12\\x39\\n\\x0eold_image_info\\x18\\n \\x01(\\x0b\\x32!.chromeos_update_engine.ImageInfo\\x12\\x39\\n\\x0enew_image_info\\x18\\x0b \\x01(\\x0b\\x32!.chromeos_update_engine.ImageInfo\\x12\\x18\\n\\rminor_version\\x18\\x0c \\x01(\\r:\\x01\\x30\\x12;\\n\\npartitions\\x18\\r \\x03(\\x0b\\x32\\'.chromeos_update_engine.PartitionUpdateB\\x02H\\x03')\n)\n_INSTALLOPERATION_TYPE = _descriptor.EnumDescriptor(\n  name='Type',\n  full_name='chromeos_update_engine.InstallOperation.Type',\n  filename=None,",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_INSTALLOPERATION_TYPE",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_INSTALLOPERATION_TYPE = _descriptor.EnumDescriptor(\n  name='Type',\n  full_name='chromeos_update_engine.InstallOperation.Type',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name='REPLACE', index=0, number=0,\n      options=None,\n      type=None),",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_EXTENT",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_EXTENT = _descriptor.Descriptor(\n  name='Extent',\n  full_name='chromeos_update_engine.Extent',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='start_block', full_name='chromeos_update_engine.Extent.start_block', index=0,\n      number=1, type=4, cpp_type=4, label=1,",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_SIGNATURES_SIGNATURE",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_SIGNATURES_SIGNATURE = _descriptor.Descriptor(\n  name='Signature',\n  full_name='chromeos_update_engine.Signatures.Signature',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='version', full_name='chromeos_update_engine.Signatures.Signature.version', index=0,\n      number=1, type=13, cpp_type=3, label=1,",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_SIGNATURES",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_SIGNATURES = _descriptor.Descriptor(\n  name='Signatures',\n  full_name='chromeos_update_engine.Signatures',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='signatures', full_name='chromeos_update_engine.Signatures.signatures', index=0,\n      number=1, type=11, cpp_type=10, label=3,",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_PARTITIONINFO",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_PARTITIONINFO = _descriptor.Descriptor(\n  name='PartitionInfo',\n  full_name='chromeos_update_engine.PartitionInfo',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='size', full_name='chromeos_update_engine.PartitionInfo.size', index=0,\n      number=1, type=4, cpp_type=4, label=1,",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_IMAGEINFO",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_IMAGEINFO = _descriptor.Descriptor(\n  name='ImageInfo',\n  full_name='chromeos_update_engine.ImageInfo',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='board', full_name='chromeos_update_engine.ImageInfo.board', index=0,\n      number=1, type=9, cpp_type=9, label=1,",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_INSTALLOPERATION",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_INSTALLOPERATION = _descriptor.Descriptor(\n  name='InstallOperation',\n  full_name='chromeos_update_engine.InstallOperation',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='type', full_name='chromeos_update_engine.InstallOperation.type', index=0,\n      number=1, type=14, cpp_type=8, label=2,",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_PARTITIONUPDATE",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_PARTITIONUPDATE = _descriptor.Descriptor(\n  name='PartitionUpdate',\n  full_name='chromeos_update_engine.PartitionUpdate',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='partition_name', full_name='chromeos_update_engine.PartitionUpdate.partition_name', index=0,\n      number=1, type=9, cpp_type=9, label=2,",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST = _descriptor.Descriptor(\n  name='DeltaArchiveManifest',\n  full_name='chromeos_update_engine.DeltaArchiveManifest',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='install_operations', full_name='chromeos_update_engine.DeltaArchiveManifest.install_operations', index=0,\n      number=1, type=11, cpp_type=10, label=3,",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_SIGNATURES_SIGNATURE.containing_type",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_SIGNATURES_SIGNATURE.containing_type = _SIGNATURES\n_SIGNATURES.fields_by_name['signatures'].message_type = _SIGNATURES_SIGNATURE\n_INSTALLOPERATION.fields_by_name['type'].enum_type = _INSTALLOPERATION_TYPE\n_INSTALLOPERATION.fields_by_name['src_extents'].message_type = _EXTENT\n_INSTALLOPERATION.fields_by_name['dst_extents'].message_type = _EXTENT\n_INSTALLOPERATION_TYPE.containing_type = _INSTALLOPERATION\n_PARTITIONUPDATE.fields_by_name['new_partition_signature'].message_type = _SIGNATURES_SIGNATURE\n_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_SIGNATURES.fields_by_name['signatures'].message_type",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_SIGNATURES.fields_by_name['signatures'].message_type = _SIGNATURES_SIGNATURE\n_INSTALLOPERATION.fields_by_name['type'].enum_type = _INSTALLOPERATION_TYPE\n_INSTALLOPERATION.fields_by_name['src_extents'].message_type = _EXTENT\n_INSTALLOPERATION.fields_by_name['dst_extents'].message_type = _EXTENT\n_INSTALLOPERATION_TYPE.containing_type = _INSTALLOPERATION\n_PARTITIONUPDATE.fields_by_name['new_partition_signature'].message_type = _SIGNATURES_SIGNATURE\n_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_INSTALLOPERATION.fields_by_name['type'].enum_type",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_INSTALLOPERATION.fields_by_name['type'].enum_type = _INSTALLOPERATION_TYPE\n_INSTALLOPERATION.fields_by_name['src_extents'].message_type = _EXTENT\n_INSTALLOPERATION.fields_by_name['dst_extents'].message_type = _EXTENT\n_INSTALLOPERATION_TYPE.containing_type = _INSTALLOPERATION\n_PARTITIONUPDATE.fields_by_name['new_partition_signature'].message_type = _SIGNATURES_SIGNATURE\n_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_INSTALLOPERATION.fields_by_name['src_extents'].message_type",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_INSTALLOPERATION.fields_by_name['src_extents'].message_type = _EXTENT\n_INSTALLOPERATION.fields_by_name['dst_extents'].message_type = _EXTENT\n_INSTALLOPERATION_TYPE.containing_type = _INSTALLOPERATION\n_PARTITIONUPDATE.fields_by_name['new_partition_signature'].message_type = _SIGNATURES_SIGNATURE\n_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_INSTALLOPERATION.fields_by_name['dst_extents'].message_type",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_INSTALLOPERATION.fields_by_name['dst_extents'].message_type = _EXTENT\n_INSTALLOPERATION_TYPE.containing_type = _INSTALLOPERATION\n_PARTITIONUPDATE.fields_by_name['new_partition_signature'].message_type = _SIGNATURES_SIGNATURE\n_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_INSTALLOPERATION_TYPE.containing_type",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_INSTALLOPERATION_TYPE.containing_type = _INSTALLOPERATION\n_PARTITIONUPDATE.fields_by_name['new_partition_signature'].message_type = _SIGNATURES_SIGNATURE\n_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_PARTITIONUPDATE.fields_by_name['new_partition_signature'].message_type",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_PARTITIONUPDATE.fields_by_name['new_partition_signature'].message_type = _SIGNATURES_SIGNATURE\n_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_PARTITIONUPDATE.fields_by_name['operations'].message_type",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['Extent'] = _EXTENT",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['Extent'] = _EXTENT\nDESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['Extent'] = _EXTENT\nDESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES\nDESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['Extent'] = _EXTENT\nDESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES\nDESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO\nDESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['Extent'] = _EXTENT\nDESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES\nDESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO\nDESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO\nDESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['Extent'] = _EXTENT\nDESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES\nDESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO\nDESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO\nDESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION\nDESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['Extent'] = _EXTENT\nDESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES\nDESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO\nDESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO\nDESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION\nDESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['Extent'] = _EXTENT\nDESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES\nDESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO\nDESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO\nDESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION\nDESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['Extent'] = _EXTENT\nDESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES\nDESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO\nDESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO\nDESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION\nDESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)\nExtent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), dict(",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR.message_types_by_name['Extent']",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR.message_types_by_name['Extent'] = _EXTENT\nDESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES\nDESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO\nDESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO\nDESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION\nDESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)\nExtent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), dict(\n  DESCRIPTOR = _EXTENT,",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR.message_types_by_name['Signatures']",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES\nDESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO\nDESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO\nDESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION\nDESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)\nExtent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), dict(\n  DESCRIPTOR = _EXTENT,\n  __module__ = 'update_metadata_pb2'",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR.message_types_by_name['PartitionInfo']",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO\nDESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO\nDESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION\nDESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)\nExtent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), dict(\n  DESCRIPTOR = _EXTENT,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.Extent)",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR.message_types_by_name['ImageInfo']",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO\nDESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION\nDESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)\nExtent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), dict(\n  DESCRIPTOR = _EXTENT,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.Extent)\n  ))",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR.message_types_by_name['InstallOperation']",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION\nDESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)\nExtent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), dict(\n  DESCRIPTOR = _EXTENT,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.Extent)\n  ))\n_sym_db.RegisterMessage(Extent)",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR.message_types_by_name['PartitionUpdate']",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)\nExtent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), dict(\n  DESCRIPTOR = _EXTENT,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.Extent)\n  ))\n_sym_db.RegisterMessage(Extent)\nSignatures = _reflection.GeneratedProtocolMessageType('Signatures', (_message.Message,), dict(",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR.message_types_by_name['DeltaArchiveManifest']",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)\nExtent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), dict(\n  DESCRIPTOR = _EXTENT,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.Extent)\n  ))\n_sym_db.RegisterMessage(Extent)\nSignatures = _reflection.GeneratedProtocolMessageType('Signatures', (_message.Message,), dict(\n  Signature = _reflection.GeneratedProtocolMessageType('Signature', (_message.Message,), dict(",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "Extent",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "Extent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), dict(\n  DESCRIPTOR = _EXTENT,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.Extent)\n  ))\n_sym_db.RegisterMessage(Extent)\nSignatures = _reflection.GeneratedProtocolMessageType('Signatures', (_message.Message,), dict(\n  Signature = _reflection.GeneratedProtocolMessageType('Signature', (_message.Message,), dict(\n    DESCRIPTOR = _SIGNATURES_SIGNATURE,\n    __module__ = 'update_metadata_pb2'",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "Signatures",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "Signatures = _reflection.GeneratedProtocolMessageType('Signatures', (_message.Message,), dict(\n  Signature = _reflection.GeneratedProtocolMessageType('Signature', (_message.Message,), dict(\n    DESCRIPTOR = _SIGNATURES_SIGNATURE,\n    __module__ = 'update_metadata_pb2'\n    # @@protoc_insertion_point(class_scope:chromeos_update_engine.Signatures.Signature)\n    ))\n  ,\n  DESCRIPTOR = _SIGNATURES,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.Signatures)",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "PartitionInfo",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "PartitionInfo = _reflection.GeneratedProtocolMessageType('PartitionInfo', (_message.Message,), dict(\n  DESCRIPTOR = _PARTITIONINFO,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.PartitionInfo)\n  ))\n_sym_db.RegisterMessage(PartitionInfo)\nImageInfo = _reflection.GeneratedProtocolMessageType('ImageInfo', (_message.Message,), dict(\n  DESCRIPTOR = _IMAGEINFO,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.ImageInfo)",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "ImageInfo",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "ImageInfo = _reflection.GeneratedProtocolMessageType('ImageInfo', (_message.Message,), dict(\n  DESCRIPTOR = _IMAGEINFO,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.ImageInfo)\n  ))\n_sym_db.RegisterMessage(ImageInfo)\nInstallOperation = _reflection.GeneratedProtocolMessageType('InstallOperation', (_message.Message,), dict(\n  DESCRIPTOR = _INSTALLOPERATION,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.InstallOperation)",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "InstallOperation",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "InstallOperation = _reflection.GeneratedProtocolMessageType('InstallOperation', (_message.Message,), dict(\n  DESCRIPTOR = _INSTALLOPERATION,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.InstallOperation)\n  ))\n_sym_db.RegisterMessage(InstallOperation)\nPartitionUpdate = _reflection.GeneratedProtocolMessageType('PartitionUpdate', (_message.Message,), dict(\n  DESCRIPTOR = _PARTITIONUPDATE,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.PartitionUpdate)",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "PartitionUpdate",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "PartitionUpdate = _reflection.GeneratedProtocolMessageType('PartitionUpdate', (_message.Message,), dict(\n  DESCRIPTOR = _PARTITIONUPDATE,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.PartitionUpdate)\n  ))\n_sym_db.RegisterMessage(PartitionUpdate)\nDeltaArchiveManifest = _reflection.GeneratedProtocolMessageType('DeltaArchiveManifest', (_message.Message,), dict(\n  DESCRIPTOR = _DELTAARCHIVEMANIFEST,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.DeltaArchiveManifest)",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DeltaArchiveManifest",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "DeltaArchiveManifest = _reflection.GeneratedProtocolMessageType('DeltaArchiveManifest', (_message.Message,), dict(\n  DESCRIPTOR = _DELTAARCHIVEMANIFEST,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.DeltaArchiveManifest)\n  ))\n_sym_db.RegisterMessage(DeltaArchiveManifest)\nDESCRIPTOR.has_options = True\nDESCRIPTOR._options = _descriptor._ParseOptions(descriptor_pb2.FileOptions(), _b('H\\003'))\n# @@protoc_insertion_point(module_scope)",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR.has_options",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR.has_options = True\nDESCRIPTOR._options = _descriptor._ParseOptions(descriptor_pb2.FileOptions(), _b('H\\003'))\n# @@protoc_insertion_point(module_scope)",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR._options",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "description": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR._options = _descriptor._ParseOptions(descriptor_pb2.FileOptions(), _b('H\\003'))\n# @@protoc_insertion_point(module_scope)",
        "detail": "bin_payload.payload_dumper-master.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "u32",
        "kind": 2,
        "importPath": "bin_payload.payload_dumper",
        "description": "bin_payload.payload_dumper",
        "peekOfCode": "def u32(x):\n    return struct.unpack('>I', x)[0]\ndef u64(x):\n    return struct.unpack('>Q', x)[0]\ndef verify_contiguous(exts):\n    blocks = 0\n    for ext in exts:\n        if ext.start_block != blocks:\n            return False\n        blocks += ext.num_blocks",
        "detail": "bin_payload.payload_dumper",
        "documentation": {}
    },
    {
        "label": "u64",
        "kind": 2,
        "importPath": "bin_payload.payload_dumper",
        "description": "bin_payload.payload_dumper",
        "peekOfCode": "def u64(x):\n    return struct.unpack('>Q', x)[0]\ndef verify_contiguous(exts):\n    blocks = 0\n    for ext in exts:\n        if ext.start_block != blocks:\n            return False\n        blocks += ext.num_blocks\n    return True\ndef data_for_op(op):",
        "detail": "bin_payload.payload_dumper",
        "documentation": {}
    },
    {
        "label": "verify_contiguous",
        "kind": 2,
        "importPath": "bin_payload.payload_dumper",
        "description": "bin_payload.payload_dumper",
        "peekOfCode": "def verify_contiguous(exts):\n    blocks = 0\n    for ext in exts:\n        if ext.start_block != blocks:\n            return False\n        blocks += ext.num_blocks\n    return True\ndef data_for_op(op):\n    p.seek(data_offset + op.data_offset)\n    data = p.read(op.data_length)",
        "detail": "bin_payload.payload_dumper",
        "documentation": {}
    },
    {
        "label": "data_for_op",
        "kind": 2,
        "importPath": "bin_payload.payload_dumper",
        "description": "bin_payload.payload_dumper",
        "peekOfCode": "def data_for_op(op):\n    p.seek(data_offset + op.data_offset)\n    data = p.read(op.data_length)\n    assert hashlib.sha256(data).digest() == op.data_sha256_hash, 'operation data hash mismatch'\n    if op.type == op.REPLACE_XZ:\n        dec = lzma.LZMADecompressor()\n        data = dec.decompress(data) \n    elif op.type == op.REPLACE_BZ:\n        dec = bz2.BZ2Decompressor()\n        data = dec.decompress(data) ",
        "detail": "bin_payload.payload_dumper",
        "documentation": {}
    },
    {
        "label": "dump_part",
        "kind": 2,
        "importPath": "bin_payload.payload_dumper",
        "description": "bin_payload.payload_dumper",
        "peekOfCode": "def dump_part(part):\n    print(part.partition_name)\n    out_file = open('%s.img' % part.partition_name, 'wb')\n    h = hashlib.sha256()\n    for op in part.operations:\n        data = data_for_op(op)\n        h.update(data)\n        out_file.write(data)\n    assert h.digest() == part.new_partition_info.hash, 'partition hash mismatch'\np = open(sys.argv[1], 'rb')",
        "detail": "bin_payload.payload_dumper",
        "documentation": {}
    },
    {
        "label": "flatten",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper",
        "description": "bin_payload.payload_dumper",
        "peekOfCode": "flatten = lambda l: [item for sublist in l for item in sublist]\ndef u32(x):\n    return struct.unpack('>I', x)[0]\ndef u64(x):\n    return struct.unpack('>Q', x)[0]\ndef verify_contiguous(exts):\n    blocks = 0\n    for ext in exts:\n        if ext.start_block != blocks:\n            return False",
        "detail": "bin_payload.payload_dumper",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper",
        "description": "bin_payload.payload_dumper",
        "peekOfCode": "p = open(sys.argv[1], 'rb')\nmagic = p.read(4)\nassert magic == b'CrAU'\nfile_format_version = u64(p.read(8))\nassert file_format_version == 2\nmanifest_size = u64(p.read(8))\nmetadata_signature_size = 0\nif file_format_version > 1:\n    metadata_signature_size = u32(p.read(4))\nmanifest = p.read(manifest_size)",
        "detail": "bin_payload.payload_dumper",
        "documentation": {}
    },
    {
        "label": "magic",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper",
        "description": "bin_payload.payload_dumper",
        "peekOfCode": "magic = p.read(4)\nassert magic == b'CrAU'\nfile_format_version = u64(p.read(8))\nassert file_format_version == 2\nmanifest_size = u64(p.read(8))\nmetadata_signature_size = 0\nif file_format_version > 1:\n    metadata_signature_size = u32(p.read(4))\nmanifest = p.read(manifest_size)\nmetadata_signature = p.read(metadata_signature_size)",
        "detail": "bin_payload.payload_dumper",
        "documentation": {}
    },
    {
        "label": "file_format_version",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper",
        "description": "bin_payload.payload_dumper",
        "peekOfCode": "file_format_version = u64(p.read(8))\nassert file_format_version == 2\nmanifest_size = u64(p.read(8))\nmetadata_signature_size = 0\nif file_format_version > 1:\n    metadata_signature_size = u32(p.read(4))\nmanifest = p.read(manifest_size)\nmetadata_signature = p.read(metadata_signature_size)\ndata_offset = p.tell()\ndam = um.DeltaArchiveManifest()",
        "detail": "bin_payload.payload_dumper",
        "documentation": {}
    },
    {
        "label": "manifest_size",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper",
        "description": "bin_payload.payload_dumper",
        "peekOfCode": "manifest_size = u64(p.read(8))\nmetadata_signature_size = 0\nif file_format_version > 1:\n    metadata_signature_size = u32(p.read(4))\nmanifest = p.read(manifest_size)\nmetadata_signature = p.read(metadata_signature_size)\ndata_offset = p.tell()\ndam = um.DeltaArchiveManifest()\ndam.ParseFromString(manifest)\nfor part in dam.partitions:",
        "detail": "bin_payload.payload_dumper",
        "documentation": {}
    },
    {
        "label": "metadata_signature_size",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper",
        "description": "bin_payload.payload_dumper",
        "peekOfCode": "metadata_signature_size = 0\nif file_format_version > 1:\n    metadata_signature_size = u32(p.read(4))\nmanifest = p.read(manifest_size)\nmetadata_signature = p.read(metadata_signature_size)\ndata_offset = p.tell()\ndam = um.DeltaArchiveManifest()\ndam.ParseFromString(manifest)\nfor part in dam.partitions:\n    for op in part.operations:",
        "detail": "bin_payload.payload_dumper",
        "documentation": {}
    },
    {
        "label": "manifest",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper",
        "description": "bin_payload.payload_dumper",
        "peekOfCode": "manifest = p.read(manifest_size)\nmetadata_signature = p.read(metadata_signature_size)\ndata_offset = p.tell()\ndam = um.DeltaArchiveManifest()\ndam.ParseFromString(manifest)\nfor part in dam.partitions:\n    for op in part.operations:\n        assert op.type in (op.REPLACE, op.REPLACE_BZ, op.REPLACE_XZ), \\\n                'unsupported op'\n    extents = flatten([op.dst_extents for op in part.operations])",
        "detail": "bin_payload.payload_dumper",
        "documentation": {}
    },
    {
        "label": "metadata_signature",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper",
        "description": "bin_payload.payload_dumper",
        "peekOfCode": "metadata_signature = p.read(metadata_signature_size)\ndata_offset = p.tell()\ndam = um.DeltaArchiveManifest()\ndam.ParseFromString(manifest)\nfor part in dam.partitions:\n    for op in part.operations:\n        assert op.type in (op.REPLACE, op.REPLACE_BZ, op.REPLACE_XZ), \\\n                'unsupported op'\n    extents = flatten([op.dst_extents for op in part.operations])\n    assert verify_contiguous(extents), 'operations do not span full image'",
        "detail": "bin_payload.payload_dumper",
        "documentation": {}
    },
    {
        "label": "data_offset",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper",
        "description": "bin_payload.payload_dumper",
        "peekOfCode": "data_offset = p.tell()\ndam = um.DeltaArchiveManifest()\ndam.ParseFromString(manifest)\nfor part in dam.partitions:\n    for op in part.operations:\n        assert op.type in (op.REPLACE, op.REPLACE_BZ, op.REPLACE_XZ), \\\n                'unsupported op'\n    extents = flatten([op.dst_extents for op in part.operations])\n    assert verify_contiguous(extents), 'operations do not span full image'\n    dump_part(part)",
        "detail": "bin_payload.payload_dumper",
        "documentation": {}
    },
    {
        "label": "dam",
        "kind": 5,
        "importPath": "bin_payload.payload_dumper",
        "description": "bin_payload.payload_dumper",
        "peekOfCode": "dam = um.DeltaArchiveManifest()\ndam.ParseFromString(manifest)\nfor part in dam.partitions:\n    for op in part.operations:\n        assert op.type in (op.REPLACE, op.REPLACE_BZ, op.REPLACE_XZ), \\\n                'unsupported op'\n    extents = flatten([op.dst_extents for op in part.operations])\n    assert verify_contiguous(extents), 'operations do not span full image'\n    dump_part(part)",
        "detail": "bin_payload.payload_dumper",
        "documentation": {}
    },
    {
        "label": "_sym_db",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_sym_db = _symbol_database.Default()\nDESCRIPTOR = _descriptor.FileDescriptor(\n  name='update_metadata.proto',\n  package='chromeos_update_engine',\n  syntax='proto2',\n  serialized_pb=_b('\\n\\x15update_metadata.proto\\x12\\x16\\x63hromeos_update_engine\\\"1\\n\\x06\\x45xtent\\x12\\x13\\n\\x0bstart_block\\x18\\x01 \\x01(\\x04\\x12\\x12\\n\\nnum_blocks\\x18\\x02 \\x01(\\x04\\\"z\\n\\nSignatures\\x12@\\n\\nsignatures\\x18\\x01 \\x03(\\x0b\\x32,.chromeos_update_engine.Signatures.Signature\\x1a*\\n\\tSignature\\x12\\x0f\\n\\x07version\\x18\\x01 \\x01(\\r\\x12\\x0c\\n\\x04\\x64\\x61ta\\x18\\x02 \\x01(\\x0c\\\"+\\n\\rPartitionInfo\\x12\\x0c\\n\\x04size\\x18\\x01 \\x01(\\x04\\x12\\x0c\\n\\x04hash\\x18\\x02 \\x01(\\x0c\\\"w\\n\\tImageInfo\\x12\\r\\n\\x05\\x62oard\\x18\\x01 \\x01(\\t\\x12\\x0b\\n\\x03key\\x18\\x02 \\x01(\\t\\x12\\x0f\\n\\x07\\x63hannel\\x18\\x03 \\x01(\\t\\x12\\x0f\\n\\x07version\\x18\\x04 \\x01(\\t\\x12\\x15\\n\\rbuild_channel\\x18\\x05 \\x01(\\t\\x12\\x15\\n\\rbuild_version\\x18\\x06 \\x01(\\t\\\"\\xd3\\x03\\n\\x10InstallOperation\\x12;\\n\\x04type\\x18\\x01 \\x02(\\x0e\\x32-.chromeos_update_engine.InstallOperation.Type\\x12\\x13\\n\\x0b\\x64\\x61ta_offset\\x18\\x02 \\x01(\\r\\x12\\x13\\n\\x0b\\x64\\x61ta_length\\x18\\x03 \\x01(\\r\\x12\\x33\\n\\x0bsrc_extents\\x18\\x04 \\x03(\\x0b\\x32\\x1e.chromeos_update_engine.Extent\\x12\\x12\\n\\nsrc_length\\x18\\x05 \\x01(\\x04\\x12\\x33\\n\\x0b\\x64st_extents\\x18\\x06 \\x03(\\x0b\\x32\\x1e.chromeos_update_engine.Extent\\x12\\x12\\n\\ndst_length\\x18\\x07 \\x01(\\x04\\x12\\x18\\n\\x10\\x64\\x61ta_sha256_hash\\x18\\x08 \\x01(\\x0c\\x12\\x17\\n\\x0fsrc_sha256_hash\\x18\\t \\x01(\\x0c\\\"\\x92\\x01\\n\\x04Type\\x12\\x0b\\n\\x07REPLACE\\x10\\x00\\x12\\x0e\\n\\nREPLACE_BZ\\x10\\x01\\x12\\x08\\n\\x04MOVE\\x10\\x02\\x12\\n\\n\\x06\\x42SDIFF\\x10\\x03\\x12\\x0f\\n\\x0bSOURCE_COPY\\x10\\x04\\x12\\x11\\n\\rSOURCE_BSDIFF\\x10\\x05\\x12\\x08\\n\\x04ZERO\\x10\\x06\\x12\\x0b\\n\\x07\\x44ISCARD\\x10\\x07\\x12\\x0e\\n\\nREPLACE_XZ\\x10\\x08\\x12\\x0c\\n\\x08PUFFDIFF\\x10\\t\\\"\\xa6\\x03\\n\\x0fPartitionUpdate\\x12\\x16\\n\\x0epartition_name\\x18\\x01 \\x02(\\t\\x12\\x17\\n\\x0frun_postinstall\\x18\\x02 \\x01(\\x08\\x12\\x18\\n\\x10postinstall_path\\x18\\x03 \\x01(\\t\\x12\\x17\\n\\x0f\\x66ilesystem_type\\x18\\x04 \\x01(\\t\\x12M\\n\\x17new_partition_signature\\x18\\x05 \\x03(\\x0b\\x32,.chromeos_update_engine.Signatures.Signature\\x12\\x41\\n\\x12old_partition_info\\x18\\x06 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12\\x41\\n\\x12new_partition_info\\x18\\x07 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12<\\n\\noperations\\x18\\x08 \\x03(\\x0b\\x32(.chromeos_update_engine.InstallOperation\\x12\\x1c\\n\\x14postinstall_optional\\x18\\t \\x01(\\x08\\\"\\xc4\\x05\\n\\x14\\x44\\x65ltaArchiveManifest\\x12\\x44\\n\\x12install_operations\\x18\\x01 \\x03(\\x0b\\x32(.chromeos_update_engine.InstallOperation\\x12K\\n\\x19kernel_install_operations\\x18\\x02 \\x03(\\x0b\\x32(.chromeos_update_engine.InstallOperation\\x12\\x18\\n\\nblock_size\\x18\\x03 \\x01(\\r:\\x04\\x34\\x30\\x39\\x36\\x12\\x19\\n\\x11signatures_offset\\x18\\x04 \\x01(\\x04\\x12\\x17\\n\\x0fsignatures_size\\x18\\x05 \\x01(\\x04\\x12>\\n\\x0fold_kernel_info\\x18\\x06 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12>\\n\\x0fnew_kernel_info\\x18\\x07 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12>\\n\\x0fold_rootfs_info\\x18\\x08 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12>\\n\\x0fnew_rootfs_info\\x18\\t \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12\\x39\\n\\x0eold_image_info\\x18\\n \\x01(\\x0b\\x32!.chromeos_update_engine.ImageInfo\\x12\\x39\\n\\x0enew_image_info\\x18\\x0b \\x01(\\x0b\\x32!.chromeos_update_engine.ImageInfo\\x12\\x18\\n\\rminor_version\\x18\\x0c \\x01(\\r:\\x01\\x30\\x12;\\n\\npartitions\\x18\\r \\x03(\\x0b\\x32\\'.chromeos_update_engine.PartitionUpdateB\\x02H\\x03')\n)\n_INSTALLOPERATION_TYPE = _descriptor.EnumDescriptor(\n  name='Type',\n  full_name='chromeos_update_engine.InstallOperation.Type',",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR = _descriptor.FileDescriptor(\n  name='update_metadata.proto',\n  package='chromeos_update_engine',\n  syntax='proto2',\n  serialized_pb=_b('\\n\\x15update_metadata.proto\\x12\\x16\\x63hromeos_update_engine\\\"1\\n\\x06\\x45xtent\\x12\\x13\\n\\x0bstart_block\\x18\\x01 \\x01(\\x04\\x12\\x12\\n\\nnum_blocks\\x18\\x02 \\x01(\\x04\\\"z\\n\\nSignatures\\x12@\\n\\nsignatures\\x18\\x01 \\x03(\\x0b\\x32,.chromeos_update_engine.Signatures.Signature\\x1a*\\n\\tSignature\\x12\\x0f\\n\\x07version\\x18\\x01 \\x01(\\r\\x12\\x0c\\n\\x04\\x64\\x61ta\\x18\\x02 \\x01(\\x0c\\\"+\\n\\rPartitionInfo\\x12\\x0c\\n\\x04size\\x18\\x01 \\x01(\\x04\\x12\\x0c\\n\\x04hash\\x18\\x02 \\x01(\\x0c\\\"w\\n\\tImageInfo\\x12\\r\\n\\x05\\x62oard\\x18\\x01 \\x01(\\t\\x12\\x0b\\n\\x03key\\x18\\x02 \\x01(\\t\\x12\\x0f\\n\\x07\\x63hannel\\x18\\x03 \\x01(\\t\\x12\\x0f\\n\\x07version\\x18\\x04 \\x01(\\t\\x12\\x15\\n\\rbuild_channel\\x18\\x05 \\x01(\\t\\x12\\x15\\n\\rbuild_version\\x18\\x06 \\x01(\\t\\\"\\xd3\\x03\\n\\x10InstallOperation\\x12;\\n\\x04type\\x18\\x01 \\x02(\\x0e\\x32-.chromeos_update_engine.InstallOperation.Type\\x12\\x13\\n\\x0b\\x64\\x61ta_offset\\x18\\x02 \\x01(\\r\\x12\\x13\\n\\x0b\\x64\\x61ta_length\\x18\\x03 \\x01(\\r\\x12\\x33\\n\\x0bsrc_extents\\x18\\x04 \\x03(\\x0b\\x32\\x1e.chromeos_update_engine.Extent\\x12\\x12\\n\\nsrc_length\\x18\\x05 \\x01(\\x04\\x12\\x33\\n\\x0b\\x64st_extents\\x18\\x06 \\x03(\\x0b\\x32\\x1e.chromeos_update_engine.Extent\\x12\\x12\\n\\ndst_length\\x18\\x07 \\x01(\\x04\\x12\\x18\\n\\x10\\x64\\x61ta_sha256_hash\\x18\\x08 \\x01(\\x0c\\x12\\x17\\n\\x0fsrc_sha256_hash\\x18\\t \\x01(\\x0c\\\"\\x92\\x01\\n\\x04Type\\x12\\x0b\\n\\x07REPLACE\\x10\\x00\\x12\\x0e\\n\\nREPLACE_BZ\\x10\\x01\\x12\\x08\\n\\x04MOVE\\x10\\x02\\x12\\n\\n\\x06\\x42SDIFF\\x10\\x03\\x12\\x0f\\n\\x0bSOURCE_COPY\\x10\\x04\\x12\\x11\\n\\rSOURCE_BSDIFF\\x10\\x05\\x12\\x08\\n\\x04ZERO\\x10\\x06\\x12\\x0b\\n\\x07\\x44ISCARD\\x10\\x07\\x12\\x0e\\n\\nREPLACE_XZ\\x10\\x08\\x12\\x0c\\n\\x08PUFFDIFF\\x10\\t\\\"\\xa6\\x03\\n\\x0fPartitionUpdate\\x12\\x16\\n\\x0epartition_name\\x18\\x01 \\x02(\\t\\x12\\x17\\n\\x0frun_postinstall\\x18\\x02 \\x01(\\x08\\x12\\x18\\n\\x10postinstall_path\\x18\\x03 \\x01(\\t\\x12\\x17\\n\\x0f\\x66ilesystem_type\\x18\\x04 \\x01(\\t\\x12M\\n\\x17new_partition_signature\\x18\\x05 \\x03(\\x0b\\x32,.chromeos_update_engine.Signatures.Signature\\x12\\x41\\n\\x12old_partition_info\\x18\\x06 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12\\x41\\n\\x12new_partition_info\\x18\\x07 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12<\\n\\noperations\\x18\\x08 \\x03(\\x0b\\x32(.chromeos_update_engine.InstallOperation\\x12\\x1c\\n\\x14postinstall_optional\\x18\\t \\x01(\\x08\\\"\\xc4\\x05\\n\\x14\\x44\\x65ltaArchiveManifest\\x12\\x44\\n\\x12install_operations\\x18\\x01 \\x03(\\x0b\\x32(.chromeos_update_engine.InstallOperation\\x12K\\n\\x19kernel_install_operations\\x18\\x02 \\x03(\\x0b\\x32(.chromeos_update_engine.InstallOperation\\x12\\x18\\n\\nblock_size\\x18\\x03 \\x01(\\r:\\x04\\x34\\x30\\x39\\x36\\x12\\x19\\n\\x11signatures_offset\\x18\\x04 \\x01(\\x04\\x12\\x17\\n\\x0fsignatures_size\\x18\\x05 \\x01(\\x04\\x12>\\n\\x0fold_kernel_info\\x18\\x06 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12>\\n\\x0fnew_kernel_info\\x18\\x07 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12>\\n\\x0fold_rootfs_info\\x18\\x08 \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12>\\n\\x0fnew_rootfs_info\\x18\\t \\x01(\\x0b\\x32%.chromeos_update_engine.PartitionInfo\\x12\\x39\\n\\x0eold_image_info\\x18\\n \\x01(\\x0b\\x32!.chromeos_update_engine.ImageInfo\\x12\\x39\\n\\x0enew_image_info\\x18\\x0b \\x01(\\x0b\\x32!.chromeos_update_engine.ImageInfo\\x12\\x18\\n\\rminor_version\\x18\\x0c \\x01(\\r:\\x01\\x30\\x12;\\n\\npartitions\\x18\\r \\x03(\\x0b\\x32\\'.chromeos_update_engine.PartitionUpdateB\\x02H\\x03')\n)\n_INSTALLOPERATION_TYPE = _descriptor.EnumDescriptor(\n  name='Type',\n  full_name='chromeos_update_engine.InstallOperation.Type',\n  filename=None,",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_INSTALLOPERATION_TYPE",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_INSTALLOPERATION_TYPE = _descriptor.EnumDescriptor(\n  name='Type',\n  full_name='chromeos_update_engine.InstallOperation.Type',\n  filename=None,\n  file=DESCRIPTOR,\n  values=[\n    _descriptor.EnumValueDescriptor(\n      name='REPLACE', index=0, number=0,\n      options=None,\n      type=None),",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_EXTENT",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_EXTENT = _descriptor.Descriptor(\n  name='Extent',\n  full_name='chromeos_update_engine.Extent',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='start_block', full_name='chromeos_update_engine.Extent.start_block', index=0,\n      number=1, type=4, cpp_type=4, label=1,",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_SIGNATURES_SIGNATURE",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_SIGNATURES_SIGNATURE = _descriptor.Descriptor(\n  name='Signature',\n  full_name='chromeos_update_engine.Signatures.Signature',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='version', full_name='chromeos_update_engine.Signatures.Signature.version', index=0,\n      number=1, type=13, cpp_type=3, label=1,",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_SIGNATURES",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_SIGNATURES = _descriptor.Descriptor(\n  name='Signatures',\n  full_name='chromeos_update_engine.Signatures',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='signatures', full_name='chromeos_update_engine.Signatures.signatures', index=0,\n      number=1, type=11, cpp_type=10, label=3,",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_PARTITIONINFO",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_PARTITIONINFO = _descriptor.Descriptor(\n  name='PartitionInfo',\n  full_name='chromeos_update_engine.PartitionInfo',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='size', full_name='chromeos_update_engine.PartitionInfo.size', index=0,\n      number=1, type=4, cpp_type=4, label=1,",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_IMAGEINFO",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_IMAGEINFO = _descriptor.Descriptor(\n  name='ImageInfo',\n  full_name='chromeos_update_engine.ImageInfo',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='board', full_name='chromeos_update_engine.ImageInfo.board', index=0,\n      number=1, type=9, cpp_type=9, label=1,",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_INSTALLOPERATION",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_INSTALLOPERATION = _descriptor.Descriptor(\n  name='InstallOperation',\n  full_name='chromeos_update_engine.InstallOperation',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='type', full_name='chromeos_update_engine.InstallOperation.type', index=0,\n      number=1, type=14, cpp_type=8, label=2,",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_PARTITIONUPDATE",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_PARTITIONUPDATE = _descriptor.Descriptor(\n  name='PartitionUpdate',\n  full_name='chromeos_update_engine.PartitionUpdate',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='partition_name', full_name='chromeos_update_engine.PartitionUpdate.partition_name', index=0,\n      number=1, type=9, cpp_type=9, label=2,",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST = _descriptor.Descriptor(\n  name='DeltaArchiveManifest',\n  full_name='chromeos_update_engine.DeltaArchiveManifest',\n  filename=None,\n  file=DESCRIPTOR,\n  containing_type=None,\n  fields=[\n    _descriptor.FieldDescriptor(\n      name='install_operations', full_name='chromeos_update_engine.DeltaArchiveManifest.install_operations', index=0,\n      number=1, type=11, cpp_type=10, label=3,",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_SIGNATURES_SIGNATURE.containing_type",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_SIGNATURES_SIGNATURE.containing_type = _SIGNATURES\n_SIGNATURES.fields_by_name['signatures'].message_type = _SIGNATURES_SIGNATURE\n_INSTALLOPERATION.fields_by_name['type'].enum_type = _INSTALLOPERATION_TYPE\n_INSTALLOPERATION.fields_by_name['src_extents'].message_type = _EXTENT\n_INSTALLOPERATION.fields_by_name['dst_extents'].message_type = _EXTENT\n_INSTALLOPERATION_TYPE.containing_type = _INSTALLOPERATION\n_PARTITIONUPDATE.fields_by_name['new_partition_signature'].message_type = _SIGNATURES_SIGNATURE\n_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_SIGNATURES.fields_by_name['signatures'].message_type",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_SIGNATURES.fields_by_name['signatures'].message_type = _SIGNATURES_SIGNATURE\n_INSTALLOPERATION.fields_by_name['type'].enum_type = _INSTALLOPERATION_TYPE\n_INSTALLOPERATION.fields_by_name['src_extents'].message_type = _EXTENT\n_INSTALLOPERATION.fields_by_name['dst_extents'].message_type = _EXTENT\n_INSTALLOPERATION_TYPE.containing_type = _INSTALLOPERATION\n_PARTITIONUPDATE.fields_by_name['new_partition_signature'].message_type = _SIGNATURES_SIGNATURE\n_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_INSTALLOPERATION.fields_by_name['type'].enum_type",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_INSTALLOPERATION.fields_by_name['type'].enum_type = _INSTALLOPERATION_TYPE\n_INSTALLOPERATION.fields_by_name['src_extents'].message_type = _EXTENT\n_INSTALLOPERATION.fields_by_name['dst_extents'].message_type = _EXTENT\n_INSTALLOPERATION_TYPE.containing_type = _INSTALLOPERATION\n_PARTITIONUPDATE.fields_by_name['new_partition_signature'].message_type = _SIGNATURES_SIGNATURE\n_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_INSTALLOPERATION.fields_by_name['src_extents'].message_type",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_INSTALLOPERATION.fields_by_name['src_extents'].message_type = _EXTENT\n_INSTALLOPERATION.fields_by_name['dst_extents'].message_type = _EXTENT\n_INSTALLOPERATION_TYPE.containing_type = _INSTALLOPERATION\n_PARTITIONUPDATE.fields_by_name['new_partition_signature'].message_type = _SIGNATURES_SIGNATURE\n_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_INSTALLOPERATION.fields_by_name['dst_extents'].message_type",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_INSTALLOPERATION.fields_by_name['dst_extents'].message_type = _EXTENT\n_INSTALLOPERATION_TYPE.containing_type = _INSTALLOPERATION\n_PARTITIONUPDATE.fields_by_name['new_partition_signature'].message_type = _SIGNATURES_SIGNATURE\n_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_INSTALLOPERATION_TYPE.containing_type",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_INSTALLOPERATION_TYPE.containing_type = _INSTALLOPERATION\n_PARTITIONUPDATE.fields_by_name['new_partition_signature'].message_type = _SIGNATURES_SIGNATURE\n_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_PARTITIONUPDATE.fields_by_name['new_partition_signature'].message_type",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_PARTITIONUPDATE.fields_by_name['new_partition_signature'].message_type = _SIGNATURES_SIGNATURE\n_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_PARTITIONUPDATE.fields_by_name['old_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_PARTITIONUPDATE.fields_by_name['new_partition_info'].message_type = _PARTITIONINFO\n_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_PARTITIONUPDATE.fields_by_name['operations'].message_type",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_PARTITIONUPDATE.fields_by_name['operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['Extent'] = _EXTENT",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['kernel_install_operations'].message_type = _INSTALLOPERATION\n_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['Extent'] = _EXTENT\nDESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['old_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['Extent'] = _EXTENT\nDESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES\nDESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['new_kernel_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['Extent'] = _EXTENT\nDESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES\nDESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO\nDESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['old_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['Extent'] = _EXTENT\nDESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES\nDESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO\nDESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO\nDESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['new_rootfs_info'].message_type = _PARTITIONINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['Extent'] = _EXTENT\nDESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES\nDESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO\nDESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO\nDESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION\nDESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['old_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['Extent'] = _EXTENT\nDESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES\nDESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO\nDESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO\nDESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION\nDESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['new_image_info'].message_type = _IMAGEINFO\n_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['Extent'] = _EXTENT\nDESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES\nDESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO\nDESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO\nDESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION\nDESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "_DELTAARCHIVEMANIFEST.fields_by_name['partitions'].message_type = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['Extent'] = _EXTENT\nDESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES\nDESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO\nDESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO\nDESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION\nDESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)\nExtent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), dict(",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR.message_types_by_name['Extent']",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR.message_types_by_name['Extent'] = _EXTENT\nDESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES\nDESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO\nDESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO\nDESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION\nDESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)\nExtent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), dict(\n  DESCRIPTOR = _EXTENT,",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR.message_types_by_name['Signatures']",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR.message_types_by_name['Signatures'] = _SIGNATURES\nDESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO\nDESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO\nDESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION\nDESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)\nExtent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), dict(\n  DESCRIPTOR = _EXTENT,\n  __module__ = 'update_metadata_pb2'",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR.message_types_by_name['PartitionInfo']",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR.message_types_by_name['PartitionInfo'] = _PARTITIONINFO\nDESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO\nDESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION\nDESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)\nExtent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), dict(\n  DESCRIPTOR = _EXTENT,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.Extent)",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR.message_types_by_name['ImageInfo']",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR.message_types_by_name['ImageInfo'] = _IMAGEINFO\nDESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION\nDESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)\nExtent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), dict(\n  DESCRIPTOR = _EXTENT,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.Extent)\n  ))",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR.message_types_by_name['InstallOperation']",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR.message_types_by_name['InstallOperation'] = _INSTALLOPERATION\nDESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)\nExtent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), dict(\n  DESCRIPTOR = _EXTENT,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.Extent)\n  ))\n_sym_db.RegisterMessage(Extent)",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR.message_types_by_name['PartitionUpdate']",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR.message_types_by_name['PartitionUpdate'] = _PARTITIONUPDATE\nDESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)\nExtent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), dict(\n  DESCRIPTOR = _EXTENT,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.Extent)\n  ))\n_sym_db.RegisterMessage(Extent)\nSignatures = _reflection.GeneratedProtocolMessageType('Signatures', (_message.Message,), dict(",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR.message_types_by_name['DeltaArchiveManifest']",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR.message_types_by_name['DeltaArchiveManifest'] = _DELTAARCHIVEMANIFEST\n_sym_db.RegisterFileDescriptor(DESCRIPTOR)\nExtent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), dict(\n  DESCRIPTOR = _EXTENT,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.Extent)\n  ))\n_sym_db.RegisterMessage(Extent)\nSignatures = _reflection.GeneratedProtocolMessageType('Signatures', (_message.Message,), dict(\n  Signature = _reflection.GeneratedProtocolMessageType('Signature', (_message.Message,), dict(",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "Extent",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "Extent = _reflection.GeneratedProtocolMessageType('Extent', (_message.Message,), dict(\n  DESCRIPTOR = _EXTENT,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.Extent)\n  ))\n_sym_db.RegisterMessage(Extent)\nSignatures = _reflection.GeneratedProtocolMessageType('Signatures', (_message.Message,), dict(\n  Signature = _reflection.GeneratedProtocolMessageType('Signature', (_message.Message,), dict(\n    DESCRIPTOR = _SIGNATURES_SIGNATURE,\n    __module__ = 'update_metadata_pb2'",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "Signatures",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "Signatures = _reflection.GeneratedProtocolMessageType('Signatures', (_message.Message,), dict(\n  Signature = _reflection.GeneratedProtocolMessageType('Signature', (_message.Message,), dict(\n    DESCRIPTOR = _SIGNATURES_SIGNATURE,\n    __module__ = 'update_metadata_pb2'\n    # @@protoc_insertion_point(class_scope:chromeos_update_engine.Signatures.Signature)\n    ))\n  ,\n  DESCRIPTOR = _SIGNATURES,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.Signatures)",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "PartitionInfo",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "PartitionInfo = _reflection.GeneratedProtocolMessageType('PartitionInfo', (_message.Message,), dict(\n  DESCRIPTOR = _PARTITIONINFO,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.PartitionInfo)\n  ))\n_sym_db.RegisterMessage(PartitionInfo)\nImageInfo = _reflection.GeneratedProtocolMessageType('ImageInfo', (_message.Message,), dict(\n  DESCRIPTOR = _IMAGEINFO,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.ImageInfo)",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "ImageInfo",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "ImageInfo = _reflection.GeneratedProtocolMessageType('ImageInfo', (_message.Message,), dict(\n  DESCRIPTOR = _IMAGEINFO,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.ImageInfo)\n  ))\n_sym_db.RegisterMessage(ImageInfo)\nInstallOperation = _reflection.GeneratedProtocolMessageType('InstallOperation', (_message.Message,), dict(\n  DESCRIPTOR = _INSTALLOPERATION,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.InstallOperation)",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "InstallOperation",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "InstallOperation = _reflection.GeneratedProtocolMessageType('InstallOperation', (_message.Message,), dict(\n  DESCRIPTOR = _INSTALLOPERATION,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.InstallOperation)\n  ))\n_sym_db.RegisterMessage(InstallOperation)\nPartitionUpdate = _reflection.GeneratedProtocolMessageType('PartitionUpdate', (_message.Message,), dict(\n  DESCRIPTOR = _PARTITIONUPDATE,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.PartitionUpdate)",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "PartitionUpdate",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "PartitionUpdate = _reflection.GeneratedProtocolMessageType('PartitionUpdate', (_message.Message,), dict(\n  DESCRIPTOR = _PARTITIONUPDATE,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.PartitionUpdate)\n  ))\n_sym_db.RegisterMessage(PartitionUpdate)\nDeltaArchiveManifest = _reflection.GeneratedProtocolMessageType('DeltaArchiveManifest', (_message.Message,), dict(\n  DESCRIPTOR = _DELTAARCHIVEMANIFEST,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.DeltaArchiveManifest)",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DeltaArchiveManifest",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "DeltaArchiveManifest = _reflection.GeneratedProtocolMessageType('DeltaArchiveManifest', (_message.Message,), dict(\n  DESCRIPTOR = _DELTAARCHIVEMANIFEST,\n  __module__ = 'update_metadata_pb2'\n  # @@protoc_insertion_point(class_scope:chromeos_update_engine.DeltaArchiveManifest)\n  ))\n_sym_db.RegisterMessage(DeltaArchiveManifest)\nDESCRIPTOR.has_options = True\nDESCRIPTOR._options = _descriptor._ParseOptions(descriptor_pb2.FileOptions(), _b('H\\003'))\n# @@protoc_insertion_point(module_scope)",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR.has_options",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR.has_options = True\nDESCRIPTOR._options = _descriptor._ParseOptions(descriptor_pb2.FileOptions(), _b('H\\003'))\n# @@protoc_insertion_point(module_scope)",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR._options",
        "kind": 5,
        "importPath": "bin_payload.update_metadata_pb2",
        "description": "bin_payload.update_metadata_pb2",
        "peekOfCode": "DESCRIPTOR._options = _descriptor._ParseOptions(descriptor_pb2.FileOptions(), _b('H\\003'))\n# @@protoc_insertion_point(module_scope)",
        "detail": "bin_payload.update_metadata_pb2",
        "documentation": {}
    },
    {
        "label": "Image",
        "kind": 6,
        "importPath": "bin_system.img2sdat-master.blockimgdiff",
        "description": "bin_system.img2sdat-master.blockimgdiff",
        "peekOfCode": "class Image(object):\n  def ReadRangeSet(self, ranges):\n    raise NotImplementedError\n  def TotalSha1(self, include_clobbered_blocks=False):\n    raise NotImplementedError\nclass EmptyImage(Image):\n  \"\"\"A zero-length image.\"\"\"\n  blocksize = 4096\n  care_map = RangeSet()\n  clobbered_blocks = RangeSet()",
        "detail": "bin_system.img2sdat-master.blockimgdiff",
        "documentation": {}
    },
    {
        "label": "EmptyImage",
        "kind": 6,
        "importPath": "bin_system.img2sdat-master.blockimgdiff",
        "description": "bin_system.img2sdat-master.blockimgdiff",
        "peekOfCode": "class EmptyImage(Image):\n  \"\"\"A zero-length image.\"\"\"\n  blocksize = 4096\n  care_map = RangeSet()\n  clobbered_blocks = RangeSet()\n  extended = RangeSet()\n  total_blocks = 0\n  file_map = {}\n  def ReadRangeSet(self, ranges):\n    return ()",
        "detail": "bin_system.img2sdat-master.blockimgdiff",
        "documentation": {}
    },
    {
        "label": "DataImage",
        "kind": 6,
        "importPath": "bin_system.img2sdat-master.blockimgdiff",
        "description": "bin_system.img2sdat-master.blockimgdiff",
        "peekOfCode": "class DataImage(Image):\n  \"\"\"An image wrapped around a single string of data.\"\"\"\n  def __init__(self, data, trim=False, pad=False):\n    self.data = data\n    self.blocksize = 4096\n    assert not (trim and pad)\n    partial = len(self.data) % self.blocksize\n    padded = False\n    if partial > 0:\n      if trim:",
        "detail": "bin_system.img2sdat-master.blockimgdiff",
        "documentation": {}
    },
    {
        "label": "Transfer",
        "kind": 6,
        "importPath": "bin_system.img2sdat-master.blockimgdiff",
        "description": "bin_system.img2sdat-master.blockimgdiff",
        "peekOfCode": "class Transfer(object):\n  def __init__(self, tgt_name, src_name, tgt_ranges, src_ranges, style, by_id):\n    self.tgt_name = tgt_name\n    self.src_name = src_name\n    self.tgt_ranges = tgt_ranges\n    self.src_ranges = src_ranges\n    self.style = style\n    self.intact = (getattr(tgt_ranges, \"monotonic\", False) and\n                   getattr(src_ranges, \"monotonic\", False))\n    # We use OrderedDict rather than dict so that the output is repeatable;",
        "detail": "bin_system.img2sdat-master.blockimgdiff",
        "documentation": {}
    },
    {
        "label": "HeapItem",
        "kind": 6,
        "importPath": "bin_system.img2sdat-master.blockimgdiff",
        "description": "bin_system.img2sdat-master.blockimgdiff",
        "peekOfCode": "class HeapItem(object):\n  def __init__(self, item):\n    self.item = item\n    # Negate the score since python's heap is a min-heap and we want\n    # the maximum score.\n    self.score = -item.score\n  def clear(self):\n    self.item = None\n  def __bool__(self):\n    return self.item is None",
        "detail": "bin_system.img2sdat-master.blockimgdiff",
        "documentation": {}
    },
    {
        "label": "BlockImageDiff",
        "kind": 6,
        "importPath": "bin_system.img2sdat-master.blockimgdiff",
        "description": "bin_system.img2sdat-master.blockimgdiff",
        "peekOfCode": "class BlockImageDiff(object):\n  def __init__(self, tgt, src=None, version=4, threads=None,\n               disable_imgdiff=False):\n    if threads is None:\n      threads = multiprocessing.cpu_count() // 2\n      if threads == 0:\n        threads = 1\n    self.threads = threads\n    self.version = version\n    self.transfers = []",
        "detail": "bin_system.img2sdat-master.blockimgdiff",
        "documentation": {}
    },
    {
        "label": "compute_patch",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.blockimgdiff",
        "description": "bin_system.img2sdat-master.blockimgdiff",
        "peekOfCode": "def compute_patch(src, tgt, imgdiff=False):\n  srcfd, srcfile = tempfile.mkstemp(prefix=\"src-\")\n  tgtfd, tgtfile = tempfile.mkstemp(prefix=\"tgt-\")\n  patchfd, patchfile = tempfile.mkstemp(prefix=\"patch-\")\n  os.close(patchfd)\n  try:\n    with os.fdopen(srcfd, \"wb\") as f_src:\n      for p in src:\n        f_src.write(p)\n    with os.fdopen(tgtfd, \"wb\") as f_tgt:",
        "detail": "bin_system.img2sdat-master.blockimgdiff",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "bin_system.img2sdat-master.blockimgdiff",
        "description": "bin_system.img2sdat-master.blockimgdiff",
        "peekOfCode": "__all__ = [\"EmptyImage\", \"DataImage\", \"BlockImageDiff\"]\ndef compute_patch(src, tgt, imgdiff=False):\n  srcfd, srcfile = tempfile.mkstemp(prefix=\"src-\")\n  tgtfd, tgtfile = tempfile.mkstemp(prefix=\"tgt-\")\n  patchfd, patchfile = tempfile.mkstemp(prefix=\"patch-\")\n  os.close(patchfd)\n  try:\n    with os.fdopen(srcfd, \"wb\") as f_src:\n      for p in src:\n        f_src.write(p)",
        "detail": "bin_system.img2sdat-master.blockimgdiff",
        "documentation": {}
    },
    {
        "label": "Options",
        "kind": 6,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "class Options(object):\n  def __init__(self):\n    platform_search_path = {\n        \"linux2\": \"out/host/linux-x86\",\n        \"darwin\": \"out/host/darwin-x86\",\n    }\n    self.search_path = platform_search_path.get(sys.platform, None)\n    self.signapk_path = \"framework/signapk.jar\"  # Relative to search_path\n    self.signapk_shared_library_path = \"lib64\"   # Relative to search_path\n    self.extra_signapk_args = []",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "ErrorCode",
        "kind": 6,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "class ErrorCode(object):\n  \"\"\"Define error_codes for failures that happen during the actual\n  update package installation.\n  Error codes 0-999 are reserved for failures before the package\n  installation (i.e. low battery, package verification failure).\n  Detailed code in 'bootable/recovery/error_code.h' \"\"\"\n  SYSTEM_VERIFICATION_FAILURE = 1000\n  SYSTEM_UPDATE_FAILURE = 1001\n  SYSTEM_UNEXPECTED_CONTENTS = 1002\n  SYSTEM_NONZERO_CONTENTS = 1003",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "ExternalError",
        "kind": 6,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "class ExternalError(RuntimeError):\n  pass\ndef Run(args, **kwargs):\n  \"\"\"Create and return a subprocess.Popen object, printing the command\n  line on the terminal if -v was specified.\"\"\"\n  if OPTIONS.verbose:\n    print(\"  running: \", \" \".join(args))\n  return subprocess.Popen(args, **kwargs)\ndef CloseInheritedPipes():\n  \"\"\" Gmake in MAC OS has file descriptor (PIPE) leak. We close those fds",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "PasswordManager",
        "kind": 6,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "class PasswordManager(object):\n  def __init__(self):\n    self.editor = os.getenv(\"EDITOR\", None)\n    self.pwfile = os.getenv(\"ANDROID_PW_FILE\", None)\n  def GetPasswords(self, items):\n    \"\"\"Get passwords corresponding to each string in 'items',\n    returning a dict.  (The dict may have keys in addition to the\n    values in 'items'.)\n    Uses the passwords in $ANDROID_PW_FILE if available, letting the\n    user edit that file to add more needed passwords.  If no editor is",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "DeviceSpecificParams",
        "kind": 6,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "class DeviceSpecificParams(object):\n  module = None\n  def __init__(self, **kwargs):\n    \"\"\"Keyword arguments to the constructor become attributes of this\n    object, which is passed to all functions in the device-specific\n    module.\"\"\"\n    for k, v in kwargs.iteritems():\n      setattr(self, k, v)\n    self.extras = OPTIONS.extras\n    if self.module is None:",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "File",
        "kind": 6,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "class File(object):\n  def __init__(self, name, data):\n    self.name = name\n    self.data = data\n    self.size = len(data)\n    self.sha1 = sha1(data).hexdigest()\n  @classmethod\n  def FromLocalFile(cls, name, diskname):\n    f = open(diskname, \"rb\")\n    data = f.read()",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "Difference",
        "kind": 6,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "class Difference(object):\n  def __init__(self, tf, sf, diff_program=None):\n    self.tf = tf\n    self.sf = sf\n    self.patch = None\n    self.diff_program = diff_program\n  def ComputePatch(self):\n    \"\"\"Compute the patch (as a string of data) needed to turn sf into\n    tf.  Returns the same tuple as GetPatch().\"\"\"\n    tf = self.tf",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "BlockDifference",
        "kind": 6,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "class BlockDifference(object):\n  def __init__(self, partition, tgt, src=None, check_first_block=False,\n               version=None, disable_imgdiff=False):\n    self.tgt = tgt\n    self.src = src\n    self.partition = partition\n    self.check_first_block = check_first_block\n    self.disable_imgdiff = disable_imgdiff\n    if version is None:\n      version = 1",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "Run",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "def Run(args, **kwargs):\n  \"\"\"Create and return a subprocess.Popen object, printing the command\n  line on the terminal if -v was specified.\"\"\"\n  if OPTIONS.verbose:\n    print(\"  running: \", \" \".join(args))\n  return subprocess.Popen(args, **kwargs)\ndef CloseInheritedPipes():\n  \"\"\" Gmake in MAC OS has file descriptor (PIPE) leak. We close those fds\n  before doing other work.\"\"\"\n  if platform.system() != \"Darwin\":",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "CloseInheritedPipes",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "def CloseInheritedPipes():\n  \"\"\" Gmake in MAC OS has file descriptor (PIPE) leak. We close those fds\n  before doing other work.\"\"\"\n  if platform.system() != \"Darwin\":\n    return\n  for d in range(3, 1025):\n    try:\n      stat = os.fstat(d)\n      if stat is not None:\n        pipebit = stat[0] & 0x1000",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "LoadInfoDict",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "def LoadInfoDict(input_file, input_dir=None):\n  \"\"\"Read and parse the META/misc_info.txt key/value pairs from the\n  input target files and return a dict.\"\"\"\n  def read_helper(fn):\n    if isinstance(input_file, zipfile.ZipFile):\n      return input_file.read(fn)\n    else:\n      path = os.path.join(input_file, *fn.split(\"/\"))\n      try:\n        with open(path) as f:",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "LoadBuildProp",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "def LoadBuildProp(read_helper):\n  try:\n    data = read_helper(\"SYSTEM/build.prop\")\n  except KeyError:\n    print(\"Warning: could not find SYSTEM/build.prop in %s\" % zip)\n    data = \"\"\n  return LoadDictionaryFromLines(data.split(\"\\n\"))\ndef LoadDictionaryFromLines(lines):\n  d = {}\n  for line in lines:",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "LoadDictionaryFromLines",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "def LoadDictionaryFromLines(lines):\n  d = {}\n  for line in lines:\n    line = line.strip()\n    if not line or line.startswith(\"#\"):\n      continue\n    if \"=\" in line:\n      name, value = line.split(\"=\", 1)\n      d[name] = value\n  return d",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "LoadRecoveryFSTab",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "def LoadRecoveryFSTab(read_helper, fstab_version, system_root_image=False):\n  class Partition(object):\n    def __init__(self, mount_point, fs_type, device, length, device2, context):\n      self.mount_point = mount_point\n      self.fs_type = fs_type\n      self.device = device\n      self.length = length\n      self.device2 = device2\n      self.context = context\n  try:",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "DumpInfoDict",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "def DumpInfoDict(d):\n  for k, v in sorted(d.items()):\n    print(\"%-25s = (%s) %s\" % (k, type(v).__name__, v))\ndef _BuildBootableImage(sourcedir, fs_config_file, info_dict=None,\n                        has_ramdisk=False):\n  \"\"\"Build a bootable image from the specified sourcedir.\n  Take a kernel, cmdline, and optionally a ramdisk directory from the input (in\n  'sourcedir'), and turn them into a boot image.  Return the image data, or\n  None if sourcedir does not appear to contains files for building the\n  requested image.\"\"\"",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "GetBootableImage",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "def GetBootableImage(name, prebuilt_name, unpack_dir, tree_subdir,\n                     info_dict=None):\n  \"\"\"Return a File object with the desired bootable image.\n  Look for it in 'unpack_dir'/BOOTABLE_IMAGES under the name 'prebuilt_name',\n  otherwise look for it under 'unpack_dir'/IMAGES, otherwise construct it from\n  the source files in 'unpack_dir'/'tree_subdir'.\"\"\"\n  prebuilt_path = os.path.join(unpack_dir, \"BOOTABLE_IMAGES\", prebuilt_name)\n  if os.path.exists(prebuilt_path):\n    print(\"using prebuilt %s from BOOTABLE_IMAGES...\" % (prebuilt_name,))\n    return File.FromLocalFile(name, prebuilt_path)",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "UnzipTemp",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "def UnzipTemp(filename, pattern=None):\n  \"\"\"Unzip the given archive into a temporary directory and return the name.\n  If filename is of the form \"foo.zip+bar.zip\", unzip foo.zip into a\n  temp dir, then unzip bar.zip into that_dir/BOOTABLE_IMAGES.\n  Returns (tempdir, zipobj) where zipobj is a zipfile.ZipFile (of the\n  main file), open for reading.\n  \"\"\"\n  tmp = tempfile.mkdtemp(prefix=\"targetfiles-\")\n  OPTIONS.tempfiles.append(tmp)\n  def unzip_to_dir(filename, dirname):",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "GetKeyPasswords",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "def GetKeyPasswords(keylist):\n  \"\"\"Given a list of keys, prompt the user to enter passwords for\n  those which require them.  Return a {key: password} dict.  password\n  will be None if the key has no password.\"\"\"\n  no_passwords = []\n  need_passwords = []\n  key_passwords = {}\n  devnull = open(\"/dev/null\", \"w+b\")\n  for k in sorted(keylist):\n    # We don't need a password for things that aren't really keys.",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "GetMinSdkVersion",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "def GetMinSdkVersion(apk_name):\n  \"\"\"Get the minSdkVersion delared in the APK. This can be both a decimal number\n  (API Level) or a codename.\n  \"\"\"\n  p = Run([\"aapt\", \"dump\", \"badging\", apk_name], stdout=subprocess.PIPE)\n  output, err = p.communicate()\n  if err:\n    raise ExternalError(\"Failed to obtain minSdkVersion: aapt return code %s\"\n        % (p.returncode,))\n  for line in output.split(\"\\n\"):",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "GetMinSdkVersionInt",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "def GetMinSdkVersionInt(apk_name, codename_to_api_level_map):\n  \"\"\"Get the minSdkVersion declared in the APK as a number (API Level). If\n  minSdkVersion is set to a codename, it is translated to a number using the\n  provided map.\n  \"\"\"\n  version = GetMinSdkVersion(apk_name)\n  try:\n    return int(version)\n  except ValueError:\n    # Not a decimal number. Codename?",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "SignFile",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "def SignFile(input_name, output_name, key, password, min_api_level=None,\n    codename_to_api_level_map=dict(),\n    whole_file=False):\n  \"\"\"Sign the input_name zip/jar/apk, producing output_name.  Use the\n  given key and password (the latter may be None if the key does not\n  have a password.\n  If whole_file is true, use the \"-w\" option to SignApk to embed a\n  signature that covers the whole file in the archive comment of the\n  zip file.\n  min_api_level is the API Level (int) of the oldest platform this file may end",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "CheckSize",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "def CheckSize(data, target, info_dict):\n  \"\"\"Check the data string passed against the max size limit, if\n  any, for the given target.  Raise exception if the data is too big.\n  Print a warning if the data is nearing the maximum size.\"\"\"\n  if target.endswith(\".img\"):\n    target = target[:-4]\n  mount_point = \"/\" + target\n  fs_type = None\n  limit = None\n  if info_dict[\"fstab\"]:",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "ReadApkCerts",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "def ReadApkCerts(tf_zip):\n  \"\"\"Given a target_files ZipFile, parse the META/apkcerts.txt file\n  and return a {package: cert} dict.\"\"\"\n  certmap = {}\n  for line in tf_zip.read(\"META/apkcerts.txt\").split(\"\\n\"):\n    line = line.strip()\n    if not line:\n      continue\n    m = re.match(r'^name=\"(.*)\"\\s+certificate=\"(.*)\"\\s+'\n                 r'private_key=\"(.*)\"$', line)",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "Usage",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "def Usage(docstring):\n  print(docstring.rstrip(\"\\n\"))\n  print(COMMON_DOCSTRING)\ndef ParseOptions(argv,\n                 docstring,\n                 extra_opts=\"\", extra_long_opts=(),\n                 extra_option_handler=None):\n  \"\"\"Parse the options in argv and return any arguments that aren't\n  flags.  docstring is the calling module's docstring, to be displayed\n  for errors and -h.  extra_opts and extra_long_opts are for flags",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "ParseOptions",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "def ParseOptions(argv,\n                 docstring,\n                 extra_opts=\"\", extra_long_opts=(),\n                 extra_option_handler=None):\n  \"\"\"Parse the options in argv and return any arguments that aren't\n  flags.  docstring is the calling module's docstring, to be displayed\n  for errors and -h.  extra_opts and extra_long_opts are for flags\n  defined by the caller, which are processed by passing them to\n  extra_option_handler.\"\"\"\n  try:",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "MakeTempFile",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "def MakeTempFile(prefix=None, suffix=None):\n  \"\"\"Make a temp file and add it to the list of things to be deleted\n  when Cleanup() is called.  Return the filename.\"\"\"\n  fd, fn = tempfile.mkstemp(prefix=prefix, suffix=suffix)\n  os.close(fd)\n  OPTIONS.tempfiles.append(fn)\n  return fn\ndef Cleanup():\n  for i in OPTIONS.tempfiles:\n    if os.path.isdir(i):",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "Cleanup",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "def Cleanup():\n  for i in OPTIONS.tempfiles:\n    if os.path.isdir(i):\n      shutil.rmtree(i)\n    else:\n      os.remove(i)\nclass PasswordManager(object):\n  def __init__(self):\n    self.editor = os.getenv(\"EDITOR\", None)\n    self.pwfile = os.getenv(\"ANDROID_PW_FILE\", None)",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "ZipWrite",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "def ZipWrite(zip_file, filename, arcname=None, perms=0o644,\n             compress_type=None):\n  import datetime\n  # http://b/18015246\n  # Python 2.7's zipfile implementation wrongly thinks that zip64 is required\n  # for files larger than 2GiB. We can work around this by adjusting their\n  # limit. Note that `zipfile.writestr()` will not work for strings larger than\n  # 2GiB. The Python interpreter sometimes rejects strings that large (though\n  # it isn't clear to me exactly what circumstances cause this).\n  # `zipfile.write()` must be used directly to work around this.",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "ZipWriteStr",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "def ZipWriteStr(zip_file, zinfo_or_arcname, data, perms=None,\n                compress_type=None):\n  \"\"\"Wrap zipfile.writestr() function to work around the zip64 limit.\n  Even with the ZIP64_LIMIT workaround, it won't allow writing a string\n  longer than 2GiB. It gives 'OverflowError: size does not fit in an int'\n  when calling crc32(bytes).\n  But it still works fine to write a shorter string into a large zip file.\n  We should use ZipWrite() whenever possible, and only use ZipWriteStr()\n  when we know the string won't be too long.\n  \"\"\"",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "ZipClose",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "def ZipClose(zip_file):\n  # http://b/18015246\n  # zipfile also refers to ZIP64_LIMIT during close() when it writes out the\n  # central directory.\n  saved_zip64_limit = zipfile.ZIP64_LIMIT\n  zipfile.ZIP64_LIMIT = (1 << 32) - 1\n  zip_file.close()\n  zipfile.ZIP64_LIMIT = saved_zip64_limit\nclass DeviceSpecificParams(object):\n  module = None",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "ComputeDifferences",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "def ComputeDifferences(diffs):\n  \"\"\"Call ComputePatch on all the Difference objects in 'diffs'.\"\"\"\n  print(len(diffs), \"diffs to compute\")\n  # Do the largest files first, to try and reduce the long-pole effect.\n  by_size = [(i.tf.size, i) for i in diffs]\n  by_size.sort(reverse=True)\n  by_size = [i[1] for i in by_size]\n  lock = threading.Lock()\n  diff_iter = iter(by_size)   # accessed under lock\n  def worker():",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "GetTypeAndDevice",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "def GetTypeAndDevice(mount_point, info):\n  fstab = info[\"fstab\"]\n  if fstab:\n    return (PARTITION_TYPES[fstab[mount_point].fs_type],\n            fstab[mount_point].device)\n  else:\n    raise KeyError\ndef ParseCertificate(data):\n  \"\"\"Parse a PEM-format certificate.\"\"\"\n  cert = []",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "ParseCertificate",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "def ParseCertificate(data):\n  \"\"\"Parse a PEM-format certificate.\"\"\"\n  cert = []\n  save = False\n  for line in data.split(\"\\n\"):\n    if \"--END CERTIFICATE--\" in line:\n      break\n    if save:\n      cert.append(line)\n    if \"--BEGIN CERTIFICATE--\" in line:",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "MakeRecoveryPatch",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "def MakeRecoveryPatch(input_dir, output_sink, recovery_img, boot_img,\n                      info_dict=None):\n  \"\"\"Generate a binary patch that creates the recovery image starting\n  with the boot image.  (Most of the space in these images is just the\n  kernel, which is identical for the two, so the resulting patch\n  should be efficient.)  Add it to the output zip, along with a shell\n  script that is run from init.rc on first boot to actually do the\n  patching and install the new recovery image.\n  recovery_img and boot_img should be File objects for the\n  corresponding images.  info should be the dictionary returned by",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "OPTIONS",
        "kind": 5,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "OPTIONS = Options()\n# Values for \"certificate\" in apkcerts that mean special things.\nSPECIAL_CERT_STRINGS = (\"PRESIGNED\", \"EXTERNAL\")\nclass ErrorCode(object):\n  \"\"\"Define error_codes for failures that happen during the actual\n  update package installation.\n  Error codes 0-999 are reserved for failures before the package\n  installation (i.e. low battery, package verification failure).\n  Detailed code in 'bootable/recovery/error_code.h' \"\"\"\n  SYSTEM_VERIFICATION_FAILURE = 1000",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "SPECIAL_CERT_STRINGS",
        "kind": 5,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "SPECIAL_CERT_STRINGS = (\"PRESIGNED\", \"EXTERNAL\")\nclass ErrorCode(object):\n  \"\"\"Define error_codes for failures that happen during the actual\n  update package installation.\n  Error codes 0-999 are reserved for failures before the package\n  installation (i.e. low battery, package verification failure).\n  Detailed code in 'bootable/recovery/error_code.h' \"\"\"\n  SYSTEM_VERIFICATION_FAILURE = 1000\n  SYSTEM_UPDATE_FAILURE = 1001\n  SYSTEM_UNEXPECTED_CONTENTS = 1002",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "COMMON_DOCSTRING",
        "kind": 5,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "COMMON_DOCSTRING = \"\"\"\n  -p  (--path)  <dir>\n      Prepend <dir>/bin to the list of places to search for binaries\n      run by this script, and expect to find jars in <dir>/framework.\n  -s  (--device_specific) <file>\n      Path to the python module containing device-specific\n      releasetools code.\n  -x  (--extra)  <key=value>\n      Add a key/value pair to the 'extras' dict, which device-specific\n      extension code may look at.",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "DIFF_PROGRAM_BY_EXT",
        "kind": 5,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "DIFF_PROGRAM_BY_EXT = {\n    \".gz\" : \"imgdiff\",\n    \".zip\" : [\"imgdiff\", \"-z\"],\n    \".jar\" : [\"imgdiff\", \"-z\"],\n    \".apk\" : [\"imgdiff\", \"-z\"],\n    \".img\" : \"imgdiff\",\n    }\nclass Difference(object):\n  def __init__(self, tf, sf, diff_program=None):\n    self.tf = tf",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "DataImage",
        "kind": 5,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "DataImage = blockimgdiff.DataImage\n# map recovery.fstab's fs_types to mount/format \"partition types\"\nPARTITION_TYPES = {\n    \"yaffs2\": \"MTD\",\n    \"mtd\": \"MTD\",\n    \"ext4\": \"EMMC\",\n    \"emmc\": \"EMMC\",\n    \"f2fs\": \"EMMC\",\n    \"squashfs\": \"EMMC\"\n}",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "PARTITION_TYPES",
        "kind": 5,
        "importPath": "bin_system.img2sdat-master.common",
        "description": "bin_system.img2sdat-master.common",
        "peekOfCode": "PARTITION_TYPES = {\n    \"yaffs2\": \"MTD\",\n    \"mtd\": \"MTD\",\n    \"ext4\": \"EMMC\",\n    \"emmc\": \"EMMC\",\n    \"f2fs\": \"EMMC\",\n    \"squashfs\": \"EMMC\"\n}\ndef GetTypeAndDevice(mount_point, info):\n  fstab = info[\"fstab\"]",
        "detail": "bin_system.img2sdat-master.common",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.img2sdat",
        "description": "bin_system.img2sdat-master.img2sdat",
        "peekOfCode": "def main(argv):\n    global input\n    if len(sys.argv) > 2 and len(sys.argv) < 4:\n        if sys.argv[len(sys.argv)-1].isdigit():\n            if int(sys.argv[len(sys.argv)-1]) < 5:\n                version = int(sys.argv[len(sys.argv)-1])\n                outdir = os.path.realpath(os.path.dirname(sys.argv[1])) + os.sep + os.path.basename(sys.argv[1]).split('.')[0]\n            else:\n                outdir = sys.argv[len(sys.argv)-1] + os.sep + os.path.basename(sys.argv[1]).split('.')[0]\n                if not os.path.exists(sys.argv[len(sys.argv)-1]):",
        "detail": "bin_system.img2sdat-master.img2sdat",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "bin_system.img2sdat-master.img2sdat",
        "description": "bin_system.img2sdat-master.img2sdat",
        "peekOfCode": "__version__ = '1.6'\nif sys.hexversion < 0x02070000:\n    print >> sys.stderr, \"Python 2.7 or newer is required.\"\n    try:\n       input = raw_input\n    except NameError: pass\n    input('Press ENTER to exit...')\n    sys.exit(1)\nelse:\n    print('img2sdat binary - version: %s\\n' % __version__)",
        "detail": "bin_system.img2sdat-master.img2sdat",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "bin_system.img2sdat-master.img2sdat5",
        "description": "bin_system.img2sdat-master.img2sdat5",
        "peekOfCode": "def main(argv):\n    global input\n    if len(sys.argv) > 2 and len(sys.argv) < 4:\n        if sys.argv[len(sys.argv)-1].isdigit():\n            if int(sys.argv[len(sys.argv)-1]) < 5:\n                version = int(sys.argv[len(sys.argv)-1])\n                outdir = os.path.realpath(os.path.dirname(sys.argv[1])) + os.sep + os.path.basename(sys.argv[1]).rsplit('.',1)[0]\n            else:\n                outdir = sys.argv[len(sys.argv)-1] + os.sep + os.path.basename(sys.argv[1]).rsplit('.',1)[0]\n                if not os.path.exists(sys.argv[len(sys.argv)-1]):",
        "detail": "bin_system.img2sdat-master.img2sdat5",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "bin_system.img2sdat-master.img2sdat5",
        "description": "bin_system.img2sdat-master.img2sdat5",
        "peekOfCode": "__version__ = '1.6'\nif sys.hexversion < 0x02070000:\n    print >> sys.stderr, \"Python 2.7 or newer is required.\"\n    try:\n        input = raw_input\n    except NameError:\n        pass\n    input('Press ENTER to exit...')\n    sys.exit(1)\nelse:",
        "detail": "bin_system.img2sdat-master.img2sdat5",
        "documentation": {}
    },
    {
        "label": "RangeSet",
        "kind": 6,
        "importPath": "bin_system.img2sdat-master.rangelib",
        "description": "bin_system.img2sdat-master.rangelib",
        "peekOfCode": "class RangeSet(object):\n  \"\"\"A RangeSet represents a set of nonoverlapping ranges on the\n  integers (ie, a set of integers, but efficient when the set contains\n  lots of runs.\"\"\"\n  def __init__(self, data=None):\n    self.monotonic = False\n    if isinstance(data, str):\n      self._parse_internal(data)\n    elif data:\n      assert len(data) % 2 == 0",
        "detail": "bin_system.img2sdat-master.rangelib",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "bin_system.img2sdat-master.rangelib",
        "description": "bin_system.img2sdat-master.rangelib",
        "peekOfCode": "__all__ = [\"RangeSet\"]\nclass RangeSet(object):\n  \"\"\"A RangeSet represents a set of nonoverlapping ranges on the\n  integers (ie, a set of integers, but efficient when the set contains\n  lots of runs.\"\"\"\n  def __init__(self, data=None):\n    self.monotonic = False\n    if isinstance(data, str):\n      self._parse_internal(data)\n    elif data:",
        "detail": "bin_system.img2sdat-master.rangelib",
        "documentation": {}
    },
    {
        "label": "SparseImage",
        "kind": 6,
        "importPath": "bin_system.img2sdat-master.sparse_img",
        "description": "bin_system.img2sdat-master.sparse_img",
        "peekOfCode": "class SparseImage(object):\n  \"\"\"Wraps a sparse image file into an image object.\n  Wraps a sparse image file (and optional file map and clobbered_blocks) into\n  an image object suitable for passing to BlockImageDiff. file_map contains\n  the mapping between files and their blocks. clobbered_blocks contains the set\n  of blocks that should be always written to the target regardless of the old\n  contents (i.e. copying instead of patching). clobbered_blocks should be in\n  the form of a string like \"0\" or \"0 1-5 8\".\n  \"\"\"\n  def __init__(self, simg_fn, file_map_fn=None, clobbered_blocks=None,",
        "detail": "bin_system.img2sdat-master.sparse_img",
        "documentation": {}
    },
    {
        "label": "Ext4Error",
        "kind": 6,
        "importPath": "bin_system.ext4",
        "description": "bin_system.ext4",
        "peekOfCode": "class Ext4Error(Exception):\n    pass\nclass BlockMapError(Ext4Error):\n    pass\nclass EndOfStreamError(Ext4Error):\n    pass\nclass MagicError(Ext4Error):\n    pass\n# ----------------------------- LOW LEVEL ------------------------------\nclass ext4_struct(ctypes.LittleEndianStructure):",
        "detail": "bin_system.ext4",
        "documentation": {}
    },
    {
        "label": "BlockMapError",
        "kind": 6,
        "importPath": "bin_system.ext4",
        "description": "bin_system.ext4",
        "peekOfCode": "class BlockMapError(Ext4Error):\n    pass\nclass EndOfStreamError(Ext4Error):\n    pass\nclass MagicError(Ext4Error):\n    pass\n# ----------------------------- LOW LEVEL ------------------------------\nclass ext4_struct(ctypes.LittleEndianStructure):\n    def __getattr__(self, name):\n        try:",
        "detail": "bin_system.ext4",
        "documentation": {}
    },
    {
        "label": "EndOfStreamError",
        "kind": 6,
        "importPath": "bin_system.ext4",
        "description": "bin_system.ext4",
        "peekOfCode": "class EndOfStreamError(Ext4Error):\n    pass\nclass MagicError(Ext4Error):\n    pass\n# ----------------------------- LOW LEVEL ------------------------------\nclass ext4_struct(ctypes.LittleEndianStructure):\n    def __getattr__(self, name):\n        try:\n            # Combining *_lo and *_hi fields\n            lo_field = ctypes.LittleEndianStructure.__getattribute__(type(self), name + \"_lo\")",
        "detail": "bin_system.ext4",
        "documentation": {}
    },
    {
        "label": "MagicError",
        "kind": 6,
        "importPath": "bin_system.ext4",
        "description": "bin_system.ext4",
        "peekOfCode": "class MagicError(Ext4Error):\n    pass\n# ----------------------------- LOW LEVEL ------------------------------\nclass ext4_struct(ctypes.LittleEndianStructure):\n    def __getattr__(self, name):\n        try:\n            # Combining *_lo and *_hi fields\n            lo_field = ctypes.LittleEndianStructure.__getattribute__(type(self), name + \"_lo\")\n            size = lo_field.size\n            lo = lo_field.__get__(self)",
        "detail": "bin_system.ext4",
        "documentation": {}
    },
    {
        "label": "ext4_struct",
        "kind": 6,
        "importPath": "bin_system.ext4",
        "description": "bin_system.ext4",
        "peekOfCode": "class ext4_struct(ctypes.LittleEndianStructure):\n    def __getattr__(self, name):\n        try:\n            # Combining *_lo and *_hi fields\n            lo_field = ctypes.LittleEndianStructure.__getattribute__(type(self), name + \"_lo\")\n            size = lo_field.size\n            lo = lo_field.__get__(self)\n            hi = ctypes.LittleEndianStructure.__getattribute__(self, name + \"_hi\")\n            return (hi << (8 * size)) | lo\n        except AttributeError:",
        "detail": "bin_system.ext4",
        "documentation": {}
    },
    {
        "label": "ext4_dir_entry_2",
        "kind": 6,
        "importPath": "bin_system.ext4",
        "description": "bin_system.ext4",
        "peekOfCode": "class ext4_dir_entry_2(ext4_struct):\n    _fields_ = [\n        (\"inode\", ctypes.c_uint),  # 0x0\n        (\"rec_len\", ctypes.c_ushort),  # 0x4\n        (\"name_len\", ctypes.c_ubyte),  # 0x6\n        (\"file_type\", ctypes.c_ubyte)  # 0x7\n        # Variable length field \"name\" missing at 0x8\n    ]\n    def _from_buffer_copy(raw, offset=0, platform64=True):\n        struct = ext4_dir_entry_2.from_buffer_copy(raw, offset)",
        "detail": "bin_system.ext4",
        "documentation": {}
    },
    {
        "label": "ext4_extent",
        "kind": 6,
        "importPath": "bin_system.ext4",
        "description": "bin_system.ext4",
        "peekOfCode": "class ext4_extent(ext4_struct):\n    _fields_ = [\n        (\"ee_block\", ctypes.c_uint),  # 0x0000\n        (\"ee_len\", ctypes.c_ushort),  # 0x0004\n        (\"ee_start_hi\", ctypes.c_ushort),  # 0x0006\n        (\"ee_start_lo\", ctypes.c_uint)  # 0x0008\n    ]\nclass ext4_extent_header(ext4_struct):\n    _fields_ = [\n        (\"eh_magic\", ctypes.c_ushort),  # 0x0000, Must be 0xF30A",
        "detail": "bin_system.ext4",
        "documentation": {}
    },
    {
        "label": "ext4_extent_header",
        "kind": 6,
        "importPath": "bin_system.ext4",
        "description": "bin_system.ext4",
        "peekOfCode": "class ext4_extent_header(ext4_struct):\n    _fields_ = [\n        (\"eh_magic\", ctypes.c_ushort),  # 0x0000, Must be 0xF30A\n        (\"eh_entries\", ctypes.c_ushort),  # 0x0002\n        (\"eh_max\", ctypes.c_ushort),  # 0x0004\n        (\"eh_depth\", ctypes.c_ushort),  # 0x0006\n        (\"eh_generation\", ctypes.c_uint)  # 0x0008\n    ]\nclass ext4_extent_idx(ext4_struct):\n    _fields_ = [",
        "detail": "bin_system.ext4",
        "documentation": {}
    },
    {
        "label": "ext4_extent_idx",
        "kind": 6,
        "importPath": "bin_system.ext4",
        "description": "bin_system.ext4",
        "peekOfCode": "class ext4_extent_idx(ext4_struct):\n    _fields_ = [\n        (\"ei_block\", ctypes.c_uint),  # 0x0000\n        (\"ei_leaf_lo\", ctypes.c_uint),  # 0x0004\n        (\"ei_leaf_hi\", ctypes.c_ushort),  # 0x0008\n        (\"ei_unused\", ctypes.c_ushort)  # 0x000A\n    ]\nclass ext4_group_descriptor(ext4_struct):\n    _fields_ = [\n        (\"bg_block_bitmap_lo\", ctypes.c_uint),  # 0x0000",
        "detail": "bin_system.ext4",
        "documentation": {}
    },
    {
        "label": "ext4_group_descriptor",
        "kind": 6,
        "importPath": "bin_system.ext4",
        "description": "bin_system.ext4",
        "peekOfCode": "class ext4_group_descriptor(ext4_struct):\n    _fields_ = [\n        (\"bg_block_bitmap_lo\", ctypes.c_uint),  # 0x0000\n        (\"bg_inode_bitmap_lo\", ctypes.c_uint),  # 0x0004\n        (\"bg_inode_table_lo\", ctypes.c_uint),  # 0x0008\n        (\"bg_free_blocks_count_lo\", ctypes.c_ushort),  # 0x000C\n        (\"bg_free_inodes_count_lo\", ctypes.c_ushort),  # 0x000E\n        (\"bg_used_dirs_count_lo\", ctypes.c_ushort),  # 0x0010\n        (\"bg_flags\", ctypes.c_ushort),  # 0x0012\n        (\"bg_exclude_bitmap_lo\", ctypes.c_uint),  # 0x0014",
        "detail": "bin_system.ext4",
        "documentation": {}
    },
    {
        "label": "ext4_inode",
        "kind": 6,
        "importPath": "bin_system.ext4",
        "description": "bin_system.ext4",
        "peekOfCode": "class ext4_inode(ext4_struct):\n    EXT2_GOOD_OLD_INODE_SIZE = 128  # Every field passing 128 bytes is \"additional data\", whose size is specified by i_extra_isize.\n    # i_mode\n    S_IXOTH = 0x1  # Others can execute\n    S_IWOTH = 0x2  # Others can write\n    S_IROTH = 0x4  # Others can read\n    S_IXGRP = 0x8  # Group can execute\n    S_IWGRP = 0x10  # Group can write\n    S_IRGRP = 0x20  # Group can read\n    S_IXUSR = 0x40  # Owner can execute",
        "detail": "bin_system.ext4",
        "documentation": {}
    },
    {
        "label": "ext4_superblock",
        "kind": 6,
        "importPath": "bin_system.ext4",
        "description": "bin_system.ext4",
        "peekOfCode": "class ext4_superblock(ext4_struct):\n    EXT2_DESC_SIZE = 0x20  # Default value for s_desc_size, if INCOMPAT_64BIT is not set (NEEDS CONFIRMATION)\n    # s_feature_incompat\n    INCOMPAT_64BIT = 0x80  # Uses 64-bit features (e.g. *_hi structure fields in ext4_group_descriptor)\n    INCOMPAT_FILETYPE = 0x2  # Directory entries record file type (instead of inode flags)\n    _fields_ = [\n        (\"s_inodes_count\", ctypes.c_uint),  # 0x0000\n        (\"s_blocks_count_lo\", ctypes.c_uint),  # 0x0004\n        (\"s_r_blocks_count_lo\", ctypes.c_uint),  # 0x0008\n        (\"s_free_blocks_count_lo\", ctypes.c_uint),  # 0x000C",
        "detail": "bin_system.ext4",
        "documentation": {}
    },
    {
        "label": "ext4_xattr_entry",
        "kind": 6,
        "importPath": "bin_system.ext4",
        "description": "bin_system.ext4",
        "peekOfCode": "class ext4_xattr_entry(ext4_struct):\n    _fields_ = [\n        (\"e_name_len\", ctypes.c_ubyte),  # 0x00\n        (\"e_name_index\", ctypes.c_ubyte),  # 0x01\n        (\"e_value_offs\", ctypes.c_ushort),  # 0x02\n        (\"e_value_inum\", ctypes.c_uint),  # 0x04\n        (\"e_value_size\", ctypes.c_uint),  # 0x08\n        (\"e_hash\", ctypes.c_uint)  # 0x0C\n        # Variable length field \"e_name\" missing at 0x10\n    ]",
        "detail": "bin_system.ext4",
        "documentation": {}
    },
    {
        "label": "ext4_xattr_header",
        "kind": 6,
        "importPath": "bin_system.ext4",
        "description": "bin_system.ext4",
        "peekOfCode": "class ext4_xattr_header(ext4_struct):\n    _fields_ = [\n        (\"h_magic\", ctypes.c_uint),  # 0x0, Must be 0xEA020000\n        (\"h_refcount\", ctypes.c_uint),  # 0x4\n        (\"h_blocks\", ctypes.c_uint),  # 0x8\n        (\"h_hash\", ctypes.c_uint),  # 0xC\n        (\"h_checksum\", ctypes.c_uint),  # 0x10\n        (\"h_reserved\", ctypes.c_uint * 3),  # 0x14\n    ]\nclass ext4_xattr_ibody_header(ext4_struct):",
        "detail": "bin_system.ext4",
        "documentation": {}
    },
    {
        "label": "ext4_xattr_ibody_header",
        "kind": 6,
        "importPath": "bin_system.ext4",
        "description": "bin_system.ext4",
        "peekOfCode": "class ext4_xattr_ibody_header(ext4_struct):\n    _fields_ = [\n        (\"h_magic\", ctypes.c_uint)  # 0x0, Must be 0xEA020000\n    ]\nclass InodeType:\n    UNKNOWN = 0x0  # Unknown file type\n    FILE = 0x1  # Regular file\n    DIRECTORY = 0x2  # Directory\n    CHARACTER_DEVICE = 0x3  # Character device\n    BLOCK_DEVICE = 0x4  # Block device",
        "detail": "bin_system.ext4",
        "documentation": {}
    },
    {
        "label": "InodeType",
        "kind": 6,
        "importPath": "bin_system.ext4",
        "description": "bin_system.ext4",
        "peekOfCode": "class InodeType:\n    UNKNOWN = 0x0  # Unknown file type\n    FILE = 0x1  # Regular file\n    DIRECTORY = 0x2  # Directory\n    CHARACTER_DEVICE = 0x3  # Character device\n    BLOCK_DEVICE = 0x4  # Block device\n    FIFO = 0x5  # FIFO\n    SOCKET = 0x6  # Socket\n    SYMBOLIC_LINK = 0x7  # Symbolic link\n    CHECKSUM = 0xDE  # Checksum entry; not really a file type, but a type of directory entry",
        "detail": "bin_system.ext4",
        "documentation": {}
    },
    {
        "label": "MappingEntry",
        "kind": 6,
        "importPath": "bin_system.ext4",
        "description": "bin_system.ext4",
        "peekOfCode": "class MappingEntry:\n    def __init__(self, file_block_idx, disk_block_idx, block_count=1):\n        self.file_block_idx = file_block_idx\n        self.disk_block_idx = disk_block_idx\n        self.block_count = block_count\n    def __iter__(self):\n        yield self.file_block_idx\n        yield self.disk_block_idx\n        yield self.block_count\n    def __repr__(self):",
        "detail": "bin_system.ext4",
        "documentation": {}
    },
    {
        "label": "Volume",
        "kind": 6,
        "importPath": "bin_system.ext4",
        "description": "bin_system.ext4",
        "peekOfCode": "class Volume:\n    ROOT_INODE = 2\n    def __init__(self, stream, offset=0, ignore_flags=False, ignore_magic=False):\n        self.ignore_flags = ignore_flags\n        self.ignore_magic = ignore_magic\n        self.offset = offset\n        self.platform64 = True  # Initial value needed for Volume.read_struct\n        self.stream = stream\n        # Superblock\n        self.superblock = self.read_struct(ext4_superblock, 0x400)",
        "detail": "bin_system.ext4",
        "documentation": {}
    },
    {
        "label": "Inode",
        "kind": 6,
        "importPath": "bin_system.ext4",
        "description": "bin_system.ext4",
        "peekOfCode": "class Inode:\n    def __init__(self, volume, offset, inode_idx, file_type=InodeType.UNKNOWN):\n        self.inode_idx = inode_idx\n        self.offset = offset\n        self.volume = volume\n        self.file_type = file_type\n        self.inode = volume.read_struct(ext4_inode, offset)\n    def __len__(self):\n        return self.inode.i_size\n    def __repr__(self):",
        "detail": "bin_system.ext4",
        "documentation": {}
    },
    {
        "label": "BlockReader",
        "kind": 6,
        "importPath": "bin_system.ext4",
        "description": "bin_system.ext4",
        "peekOfCode": "class BlockReader:\n    # OSError\n    EINVAL = 22\n    def __init__(self, volume, byte_size, block_map):\n        self.byte_size = byte_size\n        self.volume = volume\n        self.cursor = 0\n        block_map = list(map(MappingEntry.copy, block_map))\n        # Optimize mapping (stich together)\n        MappingEntry.optimize(block_map)",
        "detail": "bin_system.ext4",
        "documentation": {}
    },
    {
        "label": "wcscmp",
        "kind": 2,
        "importPath": "bin_system.ext4",
        "description": "bin_system.ext4",
        "peekOfCode": "def wcscmp(str_a, str_b):\n    for a, b in zip(str_a, str_b):\n        tmp = ord(a) - ord(b)\n        if tmp != 0: return -1 if tmp < 0 else 1\n    tmp = len(str_a) - len(str_b)\n    return -1 if tmp < 0 else 1 if tmp > 0 else 0\nclass Ext4Error(Exception):\n    pass\nclass BlockMapError(Ext4Error):\n    pass",
        "detail": "bin_system.ext4",
        "documentation": {}
    },
    {
        "label": "finder",
        "kind": 2,
        "importPath": "bin_system.find1",
        "description": "bin_system.find1",
        "peekOfCode": "def finder(file, whatfind):\n    whatfind=bytes.fromhex(whatfind)\n    size=os.stat(file).st_size\n    read_dump=64000000\n    with open(file, \"rb\") as f:\n        if size>read_dump:\n            mm=f.read(read_dump)\n        else:\n            mm=f.read()\n        offfset=mm.find(whatfind)",
        "detail": "bin_system.find1",
        "documentation": {}
    },
    {
        "label": "reversefinder",
        "kind": 2,
        "importPath": "bin_system.find_avb",
        "description": "bin_system.find_avb",
        "peekOfCode": "def reversefinder(file, whatfind):\n    whatfind=bytes.fromhex(whatfind)\n    size=os.stat(file).st_size\n    read_dump=128000000\n    with open(file, \"rb\") as f:\n        if size>read_dump:\n            f.seek(size-read_dump)\n            mm=f.read(read_dump)\n        else:\n            mm=mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)",
        "detail": "bin_system.find_avb",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "bin_system.find_avb",
        "description": "bin_system.find_avb",
        "peekOfCode": "def main(file, whatfind, savefolder):\n    offset=reversefinder(file, whatfind)\n    if offset>0:\n        avbtxt=os.path.basename(os.path.abspath(file))\n        #avb=re.sub('[[|.|+|(|-|_]',' ', avbtxt).split(' ')[0]\n        avb=re.split('\\[|\\.|\\+|\\(|-|_| ', avbtxt, maxsplit=1)[0]\n        fileavbtxt=savefolder + os.sep + avb + \"_size_avb.txt\"\n        ftxt=open(fileavbtxt,'tw')\n        print(offset,file=ftxt)\n        ftxt.close()",
        "detail": "bin_system.find_avb",
        "documentation": {}
    },
    {
        "label": "reversefinder",
        "kind": 2,
        "importPath": "bin_system.find_avb0",
        "description": "bin_system.find_avb0",
        "peekOfCode": "def reversefinder(file, whatfind):\n    whatfind=bytes.fromhex(whatfind)\n    size=os.stat(file).st_size\n    read_dump=64000000\n    with open(file, \"rb\") as f:\n        if size>read_dump:\n            f.seek(size-read_dump)\n            mm=f.read(read_dump)\n        else:\n            mm=mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)",
        "detail": "bin_system.find_avb0",
        "documentation": {}
    },
    {
        "label": "finder",
        "kind": 2,
        "importPath": "bin_system.find_gz",
        "description": "bin_system.find_gz",
        "peekOfCode": "def finder(file, whatfind):\n    whatfind=bytes.fromhex(whatfind)\n    size=os.stat(file).st_size\n    read_dump=size\n    with open(file, \"rb\") as f:\n        f.seek(size-read_dump)\n        mm=f.read(read_dump)\n        offfset=mm.find(whatfind)\n        if offfset>=0:\n            offfset=(size-read_dump)+offfset",
        "detail": "bin_system.find_gz",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "bin_system.find_gz",
        "description": "bin_system.find_gz",
        "peekOfCode": "def main(file, whatfind, savefolder):\n    offset=finder(file, whatfind)\n    if offset>=0:\n        #fileavbtxt=\"kernel.txt\"\n        #ftxt=open(fileavbtxt,'tw')\n        #print(offset,file=ftxt)\n        #ftxt.close()\n        size=os.stat(file).st_size\n        nwritebyte=size-offset\n        with open(file,'rb') as f:",
        "detail": "bin_system.find_gz",
        "documentation": {}
    },
    {
        "label": "ext4_file_header",
        "kind": 6,
        "importPath": "bin_system.imgextractor1",
        "description": "bin_system.imgextractor1",
        "peekOfCode": "class ext4_file_header(object):\n    def __init__(self, buf):\n        (self.magic,\n         self.major,\n         self.minor,\n         self.file_header_size,\n         self.chunk_header_size,\n         self.block_size,\n         self.total_blocks,\n         self.total_chunks,",
        "detail": "bin_system.imgextractor1",
        "documentation": {}
    },
    {
        "label": "ext4_chunk_header",
        "kind": 6,
        "importPath": "bin_system.imgextractor1",
        "description": "bin_system.imgextractor1",
        "peekOfCode": "class ext4_chunk_header(object):\n    def __init__(self, buf):\n        (self.type,\n         self.reserved,\n         self.chunk_size,\n         self.total_size) = struct.unpack('<2H2I', buf)\nclass Extractor(object):\n    def __init__(self):\n        self.FileName = \"\"\n        self.BASE_DIR = \"\"",
        "detail": "bin_system.imgextractor1",
        "documentation": {}
    },
    {
        "label": "Extractor",
        "kind": 6,
        "importPath": "bin_system.imgextractor1",
        "description": "bin_system.imgextractor1",
        "peekOfCode": "class Extractor(object):\n    def __init__(self):\n        self.FileName = \"\"\n        self.BASE_DIR = \"\"\n        self.OUTPUT_IMAGE_FILE = \"\"\n        self.EXTRACT_DIR = \"\"\n        self.BLOCK_SIZE = 4096\n        self.TYPE_IMG = 'system'\n        self.context = []\n        self.fsconfig = []",
        "detail": "bin_system.imgextractor1",
        "documentation": {}
    },
    {
        "label": "EXT4_HEADER_MAGIC",
        "kind": 5,
        "importPath": "bin_system.imgextractor1",
        "description": "bin_system.imgextractor1",
        "peekOfCode": "EXT4_HEADER_MAGIC = 0xED26FF3A\nEXT4_SPARSE_HEADER_LEN = 28\nEXT4_CHUNK_HEADER_SIZE = 12\nclass ext4_file_header(object):\n    def __init__(self, buf):\n        (self.magic,\n         self.major,\n         self.minor,\n         self.file_header_size,\n         self.chunk_header_size,",
        "detail": "bin_system.imgextractor1",
        "documentation": {}
    },
    {
        "label": "EXT4_SPARSE_HEADER_LEN",
        "kind": 5,
        "importPath": "bin_system.imgextractor1",
        "description": "bin_system.imgextractor1",
        "peekOfCode": "EXT4_SPARSE_HEADER_LEN = 28\nEXT4_CHUNK_HEADER_SIZE = 12\nclass ext4_file_header(object):\n    def __init__(self, buf):\n        (self.magic,\n         self.major,\n         self.minor,\n         self.file_header_size,\n         self.chunk_header_size,\n         self.block_size,",
        "detail": "bin_system.imgextractor1",
        "documentation": {}
    },
    {
        "label": "EXT4_CHUNK_HEADER_SIZE",
        "kind": 5,
        "importPath": "bin_system.imgextractor1",
        "description": "bin_system.imgextractor1",
        "peekOfCode": "EXT4_CHUNK_HEADER_SIZE = 12\nclass ext4_file_header(object):\n    def __init__(self, buf):\n        (self.magic,\n         self.major,\n         self.minor,\n         self.file_header_size,\n         self.chunk_header_size,\n         self.block_size,\n         self.total_blocks,",
        "detail": "bin_system.imgextractor1",
        "documentation": {}
    },
    {
        "label": "writebyte",
        "kind": 2,
        "importPath": "bin_system.int",
        "description": "bin_system.int",
        "peekOfCode": "def writebyte(file,offset,value):\n    fh = open(file, \"rb+\")\n    fh.seek(int(offset,16))\n    fh.write(bytes.fromhex(value))\n    fh.close()\nif __name__ == '__main__':\n    if sys.argv.__len__() == 4:\n        writebyte(sys.argv[1], sys.argv[2], sys.argv[3])",
        "detail": "bin_system.int",
        "documentation": {}
    },
    {
        "label": "BootWork",
        "kind": 6,
        "importPath": "bin_system.main",
        "description": "bin_system.main",
        "peekOfCode": "class BootWork:\n    def __init__(self, filename):\n        with open(filename, 'r+b') as f:\n            header = struct.Struct('8s I I I I I I I I I 4x 16s 512s 8x')\n            magic, kernel_size, kernel_addr, ramdisk_size, ramdisk_addr, second_size, second_addr, \\\n                tags_addr, page_size, dt_size, name, cmdline = header.unpack(f.read(header.size))\n            if magic != b'ANDROID!':\n                raise Exception(f\"{filename} is not a valid android boot image\\n\")\n            if kernel_size > 0:\n                zimg_fobj = self.dump_part(f, page_size, kernel_size)",
        "detail": "bin_system.main",
        "documentation": {}
    },
    {
        "label": "Patch",
        "kind": 6,
        "importPath": "bin_system.main",
        "description": "bin_system.main",
        "peekOfCode": "class Patch:\n    def __init__(self, zimg_file):\n        self.zimg_file = zimg_file\n        self.split_zimg(zimg_file)\n        self.new_zimg_data = self.join_zimg()\n        if self.zimg_len != len(self.new_zimg_data):\n            error_msg = \"Your kernel is probably corrupted or been tampered with \\\n                     If you have a rare device, or getting this after you check \\\n                     everything, create an issue on github.\"\n            raise Exception(f\"ERROR: Size mismatch!\\n{error_msg}\")",
        "detail": "bin_system.main",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "bin_system.main",
        "description": "bin_system.main",
        "peekOfCode": "def main():\n    #ver = platform.python_version()\n    #ver = tuple(map(int, (ver.split(\".\"))))\n    #min_ver = tuple(map(int, (\"3.9.0\".split(\".\"))))\n    #if ver < min_ver:\n        #sys.exit(\"ERROR: Python version too old. at least 3.9.0\")\n    if len(sys.argv) == 1:\n        sys.exit(help_message)\n    if sys.argv[1] in ['-h', '--help']:\n        sys.exit(help_message)",
        "detail": "bin_system.main",
        "documentation": {}
    },
    {
        "label": "printi",
        "kind": 2,
        "importPath": "bin_system.main",
        "description": "bin_system.main",
        "peekOfCode": "def printi(text):\n    print(f\"INFO: {text}\")\ndef find_7z():\n    if not windows:\n        return '7zz' if which('7zz') != None else '7z'\n    key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, \"Software\\\\7-Zip\")\n    path =  winreg.QueryValueEx(key, \"Path\")[0] + \"7z.exe\"\n    printi(f\"Found 7-Zip at: {path}\")\n    return path\nsz = find_7z()",
        "detail": "bin_system.main",
        "documentation": {}
    },
    {
        "label": "find_7z",
        "kind": 2,
        "importPath": "bin_system.main",
        "description": "bin_system.main",
        "peekOfCode": "def find_7z():\n    if not windows:\n        return '7zz' if which('7zz') != None else '7z'\n    key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, \"Software\\\\7-Zip\")\n    path =  winreg.QueryValueEx(key, \"Path\")[0] + \"7z.exe\"\n    printi(f\"Found 7-Zip at: {path}\")\n    return path\nsz = find_7z()\nclass BootWork:\n    def __init__(self, filename):",
        "detail": "bin_system.main",
        "documentation": {}
    },
    {
        "label": "help_message",
        "kind": 5,
        "importPath": "bin_system.main",
        "description": "bin_system.main",
        "peekOfCode": "help_message = f\"\"\"Usage: {sys.argv[0]} <kernel>\nDescription:\n    Makes 32bit SAR kernels boot ramdisk.\n    Refer to README.md for additional instructions.\"\"\"\ndef main():\n    #ver = platform.python_version()\n    #ver = tuple(map(int, (ver.split(\".\"))))\n    #min_ver = tuple(map(int, (\"3.9.0\".split(\".\"))))\n    #if ver < min_ver:\n        #sys.exit(\"ERROR: Python version too old. at least 3.9.0\")",
        "detail": "bin_system.main",
        "documentation": {}
    },
    {
        "label": "sz",
        "kind": 5,
        "importPath": "bin_system.main",
        "description": "bin_system.main",
        "peekOfCode": "sz = find_7z()\nclass BootWork:\n    def __init__(self, filename):\n        with open(filename, 'r+b') as f:\n            header = struct.Struct('8s I I I I I I I I I 4x 16s 512s 8x')\n            magic, kernel_size, kernel_addr, ramdisk_size, ramdisk_addr, second_size, second_addr, \\\n                tags_addr, page_size, dt_size, name, cmdline = header.unpack(f.read(header.size))\n            if magic != b'ANDROID!':\n                raise Exception(f\"{filename} is not a valid android boot image\\n\")\n            if kernel_size > 0:",
        "detail": "bin_system.main",
        "documentation": {}
    },
    {
        "label": "keytest",
        "kind": 2,
        "importPath": "bin_system.ozipdecrypt",
        "description": "bin_system.ozipdecrypt",
        "peekOfCode": "def keytest(data):\n    for key in keys:\n        ctx = AES.new(binascii.unhexlify(key), AES.MODE_ECB)\n        dat = ctx.decrypt(data)\n        if (dat[0:4] == b'\\x50\\x4B\\x03\\x04'):\n            print(\"Found correct AES key: \" + key)\n            return binascii.unhexlify(key)\n        elif (dat[0:4] == b'\\x41\\x56\\x42\\x30'):\n            print(\"Found correct AES key: \" + key)\n            return binascii.unhexlify(key)",
        "detail": "bin_system.ozipdecrypt",
        "documentation": {}
    },
    {
        "label": "del_rw",
        "kind": 2,
        "importPath": "bin_system.ozipdecrypt",
        "description": "bin_system.ozipdecrypt",
        "peekOfCode": "def del_rw(action, name, exc):\n    os.chmod(name, stat.S_IWRITE)\n    os.remove(name)\ndef rmrf(path):\n    if os.path.exists(path):\n        if os.path.isfile(path):\n            del_rw(\"\", path, \"\")\n        else:\n            shutil.rmtree(path, onerror=del_rw)\ndef decryptfile(key, rfilename):",
        "detail": "bin_system.ozipdecrypt",
        "documentation": {}
    },
    {
        "label": "rmrf",
        "kind": 2,
        "importPath": "bin_system.ozipdecrypt",
        "description": "bin_system.ozipdecrypt",
        "peekOfCode": "def rmrf(path):\n    if os.path.exists(path):\n        if os.path.isfile(path):\n            del_rw(\"\", path, \"\")\n        else:\n            shutil.rmtree(path, onerror=del_rw)\ndef decryptfile(key, rfilename):\n    with open(rfilename,'rb') as rr:\n        with open(rfilename+\".tmp\", 'wb') as wf:\n            rr.seek(0x10)",
        "detail": "bin_system.ozipdecrypt",
        "documentation": {}
    },
    {
        "label": "decryptfile",
        "kind": 2,
        "importPath": "bin_system.ozipdecrypt",
        "description": "bin_system.ozipdecrypt",
        "peekOfCode": "def decryptfile(key, rfilename):\n    with open(rfilename,'rb') as rr:\n        with open(rfilename+\".tmp\", 'wb') as wf:\n            rr.seek(0x10)\n            dsize = int(rr.read(0x10).replace(b\"\\x00\", b\"\").decode('utf-8'), 10)\n            rr.seek(0x1050)\n            print(\"Decrypting \" + rfilename)\n            flen = os.stat(rfilename).st_size - 0x1050\n            ctx = AES.new(key, AES.MODE_ECB)\n            while (dsize > 0):",
        "detail": "bin_system.ozipdecrypt",
        "documentation": {}
    },
    {
        "label": "decryptfile2",
        "kind": 2,
        "importPath": "bin_system.ozipdecrypt",
        "description": "bin_system.ozipdecrypt",
        "peekOfCode": "def decryptfile2(key, rfilename, wfilename):\n    with open(rfilename,'rb') as rr:\n        with open(wfilename, 'wb') as wf:\n            print(\"Decrypting \" + rfilename)\n            ctx = AES.new(key, AES.MODE_ECB)\n            bstart = 0\n            goon = True\n            while (goon):\n                rr.seek(bstart)\n                header = rr.read(12)",
        "detail": "bin_system.ozipdecrypt",
        "documentation": {}
    },
    {
        "label": "mode2",
        "kind": 2,
        "importPath": "bin_system.ozipdecrypt",
        "description": "bin_system.ozipdecrypt",
        "peekOfCode": "def mode2(filename):\n    temp=os.path.join(os.path.abspath(os.path.dirname(filename)), \"temp\")\n    out=os.path.join(os.path.abspath(os.path.dirname(filename)), \"out\")\n    with open(filename, 'rb') as fr:\n        magic = fr.read(12)\n        if magic[:2] == b\"PK\":\n            testkey = True\n            with ZipFile(sys.argv[1], 'r') as zipObj:\n                if os.path.exists(temp):\n                    rmrf(temp)",
        "detail": "bin_system.ozipdecrypt",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "bin_system.ozipdecrypt",
        "description": "bin_system.ozipdecrypt",
        "peekOfCode": "def main():\n    print(\"ozipdecrypt 1.1 (c) B.Kerler 2017-2020\")\n    filename=args[\"<filename>\"]\n    with open(filename, 'rb') as fr:\n        magic = fr.read(12)\n        if (magic == b\"OPPOENCRYPT!\"):\n            pk = False\n        elif magic[:2] == b\"PK\":\n            pk = True\n        else:",
        "detail": "bin_system.ozipdecrypt",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "bin_system.ozipdecrypt",
        "description": "bin_system.ozipdecrypt",
        "peekOfCode": "args = docopt(__doc__, version='1.2')\nimport os\nimport sys, stat\nimport shutil\nimport binascii\nfrom Crypto.Cipher import AES\nfrom zipfile import ZipFile\nkeys = [\n    \"D6EECF0AE5ACD4E0E9FE522DE7CE381E\",  # mnkey\n    \"D6ECCF0AE5ACD4E0E92E522DE7C1381E\",  # mkey",
        "detail": "bin_system.ozipdecrypt",
        "documentation": {}
    },
    {
        "label": "keys",
        "kind": 5,
        "importPath": "bin_system.ozipdecrypt",
        "description": "bin_system.ozipdecrypt",
        "peekOfCode": "keys = [\n    \"D6EECF0AE5ACD4E0E9FE522DE7CE381E\",  # mnkey\n    \"D6ECCF0AE5ACD4E0E92E522DE7C1381E\",  # mkey\n    \"D6DCCF0AD5ACD4E0292E522DB7C1381E\",  # realkey, R9s CPH1607 MSM8953, Plus, R11, RMX1921 Realme XT, RMX1851EX Realme Android 10, RMX1992EX_11_OTA_1050\n    \"D7DCCE1AD4AFDCE2393E5161CBDC4321\",  # testkey\n    \"D7DBCE2AD4ADDCE1393E5521CBDC4321\",  # utilkey\n    \"D7DBCE1AD4AFDCE1393E5121CBDC4321\",  # R11s CPH1719 MSM8976, Plus\n    \"D4D2CD61D4AFDCE13B5E01221BD14D20\",  # FindX CPH1871 SDM845\n    \"261CC7131D7C1481294E532DB752381E\",  # FindX\n    \"1CA21E12271335AE33AB81B2A7B14622\",  # Realme 2 pro SDM660/MSM8976",
        "detail": "bin_system.ozipdecrypt",
        "documentation": {}
    },
    {
        "label": "Qfil",
        "kind": 6,
        "importPath": "bin_system.qfil",
        "description": "bin_system.qfil",
        "peekOfCode": "class Qfil(object):\n    def __init__(self):\n        self.target_dir = None\n        self.list_work = []\n        self.out_file = None\n        self.name = None\n        self.buffer = 8192\n        self.sektor_size = 512\n    def __parseXML(self, file_path):\n        e = xml.etree.ElementTree.parse(file_path).getroot()",
        "detail": "bin_system.qfil",
        "documentation": {}
    },
    {
        "label": "Qfil",
        "kind": 6,
        "importPath": "bin_system.qfil1",
        "description": "bin_system.qfil1",
        "peekOfCode": "class Qfil(object):\n    def __init__(self):\n        self.target_dir = None\n        self.list_work = []\n        self.out_file = None\n        self.name = None\n        self.buffer = 8192\n        self.sektor_size = 512\n    def _parse_xml(self, file_path, name_label):\n        e = xml.etree.ElementTree.parse(file_path).getroot()",
        "detail": "bin_system.qfil1",
        "documentation": {}
    },
    {
        "label": "replacebyte",
        "kind": 2,
        "importPath": "bin_system.replacebyte-1",
        "description": "bin_system.replacebyte-1",
        "peekOfCode": "def replacebyte(file,whatfind,whatreplace):\n      if whatreplace=='' or len(whatreplace)==0:\n          for i in range(len(whatfind)):\n              whatreplace=whatreplace+'0'\n      if whatfind.isdigit() == True:\n          whatfind=str(hex(int(whatfind)))[2:]\n      if whatfind[:2]=='0x':\n          whatfind=whatfind[2:]\n      if (len(whatfind)/2).is_integer()==False:\n          whatfind='0'+whatfind",
        "detail": "bin_system.replacebyte-1",
        "documentation": {}
    },
    {
        "label": "HeaderAPP",
        "kind": 6,
        "importPath": "bin_system.splitapp_v2",
        "description": "bin_system.splitapp_v2",
        "peekOfCode": "class HeaderAPP:\n    # Format Header 3I8s2I16s16s16s16s3H\n    MAGIC: int  # 4 bytes\n    HEADER_LENGTH: int  # 4 bytes\n    HARDWARE_ID: str  # 8 bytes\n    FILE_SEQUENCE: int  # 4 bytes\n    FILE_SIZE: int  # 4 bytes\n    FILE_DATE: str  # 16 bytes\n    FILE_TIME: str  # 16 bytes\n    FILE_NAME: str  # 16 bytes",
        "detail": "bin_system.splitapp_v2",
        "documentation": {}
    },
    {
        "label": "ImageMetada",
        "kind": 6,
        "importPath": "bin_system.splitapp_v2",
        "description": "bin_system.splitapp_v2",
        "peekOfCode": "class ImageMetada:\n    name: str\n    path: Path\n    start: int\n    size: int\nclass SplitAPP:\n    def __init__(self, *, input_file: Union[str, Path], out_dir: Union[str, Path]):\n        if isinstance(input_file, str):\n            input_file = Path(input_file)\n        if isinstance(out_dir, str):",
        "detail": "bin_system.splitapp_v2",
        "documentation": {}
    },
    {
        "label": "SplitAPP",
        "kind": 6,
        "importPath": "bin_system.splitapp_v2",
        "description": "bin_system.splitapp_v2",
        "peekOfCode": "class SplitAPP:\n    def __init__(self, *, input_file: Union[str, Path], out_dir: Union[str, Path]):\n        if isinstance(input_file, str):\n            input_file = Path(input_file)\n        if isinstance(out_dir, str):\n            out_dir = Path(out_dir)\n        self._out_dir = out_dir\n        self._input_file = open(input_file, 'rb')\n        self._size = self._get_file_size()\n        self._input_file.seek(HEADER_OFFSET, 0)",
        "detail": "bin_system.splitapp_v2",
        "documentation": {}
    },
    {
        "label": "create_parser",
        "kind": 2,
        "importPath": "bin_system.splitapp_v2",
        "description": "bin_system.splitapp_v2",
        "peekOfCode": "def create_parser():\n    _parser = argparse.ArgumentParser(description='Split UPDATE.APP file into img files')\n    _parser.add_argument('-v', '--version', action='version',\n                         version=f'version [{__version__}]')\n    required = _parser.add_argument_group('Required')\n    required.add_argument(\"-f\", \"--filename\", required=True, help=\"Path to update.app file\")\n    required.add_argument(\"-o\", \"--out-dir\", required=True, help=\"Path to output dir\")\n    optional = _parser.add_argument_group('Optional')\n    optional.add_argument(\"-b\", \"--buffer-size\", help=\"Buffer size\")\n    optional.add_argument(\"-l\", \"--list\", nargs=\"*\", metavar=('img1', 'img2'), help=\"List of img files to extract\")",
        "detail": "bin_system.splitapp_v2",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "bin_system.splitapp_v2",
        "description": "bin_system.splitapp_v2",
        "peekOfCode": "__author__ = 'MiuiPro.info DEV Team'\n__copyright__ = 'Copyright (c) 2021 MiuiPro.info'\n__version__ = '1.0.0'\nHEADER_OFFSET = 0x5C\nMAGIC_HEADER = 0x55AA5AA5\n@dataclass\nclass HeaderAPP:\n    # Format Header 3I8s2I16s16s16s16s3H\n    MAGIC: int  # 4 bytes\n    HEADER_LENGTH: int  # 4 bytes",
        "detail": "bin_system.splitapp_v2",
        "documentation": {}
    },
    {
        "label": "__copyright__",
        "kind": 5,
        "importPath": "bin_system.splitapp_v2",
        "description": "bin_system.splitapp_v2",
        "peekOfCode": "__copyright__ = 'Copyright (c) 2021 MiuiPro.info'\n__version__ = '1.0.0'\nHEADER_OFFSET = 0x5C\nMAGIC_HEADER = 0x55AA5AA5\n@dataclass\nclass HeaderAPP:\n    # Format Header 3I8s2I16s16s16s16s3H\n    MAGIC: int  # 4 bytes\n    HEADER_LENGTH: int  # 4 bytes\n    HARDWARE_ID: str  # 8 bytes",
        "detail": "bin_system.splitapp_v2",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "bin_system.splitapp_v2",
        "description": "bin_system.splitapp_v2",
        "peekOfCode": "__version__ = '1.0.0'\nHEADER_OFFSET = 0x5C\nMAGIC_HEADER = 0x55AA5AA5\n@dataclass\nclass HeaderAPP:\n    # Format Header 3I8s2I16s16s16s16s3H\n    MAGIC: int  # 4 bytes\n    HEADER_LENGTH: int  # 4 bytes\n    HARDWARE_ID: str  # 8 bytes\n    FILE_SEQUENCE: int  # 4 bytes",
        "detail": "bin_system.splitapp_v2",
        "documentation": {}
    },
    {
        "label": "HEADER_OFFSET",
        "kind": 5,
        "importPath": "bin_system.splitapp_v2",
        "description": "bin_system.splitapp_v2",
        "peekOfCode": "HEADER_OFFSET = 0x5C\nMAGIC_HEADER = 0x55AA5AA5\n@dataclass\nclass HeaderAPP:\n    # Format Header 3I8s2I16s16s16s16s3H\n    MAGIC: int  # 4 bytes\n    HEADER_LENGTH: int  # 4 bytes\n    HARDWARE_ID: str  # 8 bytes\n    FILE_SEQUENCE: int  # 4 bytes\n    FILE_SIZE: int  # 4 bytes",
        "detail": "bin_system.splitapp_v2",
        "documentation": {}
    },
    {
        "label": "MAGIC_HEADER",
        "kind": 5,
        "importPath": "bin_system.splitapp_v2",
        "description": "bin_system.splitapp_v2",
        "peekOfCode": "MAGIC_HEADER = 0x55AA5AA5\n@dataclass\nclass HeaderAPP:\n    # Format Header 3I8s2I16s16s16s16s3H\n    MAGIC: int  # 4 bytes\n    HEADER_LENGTH: int  # 4 bytes\n    HARDWARE_ID: str  # 8 bytes\n    FILE_SEQUENCE: int  # 4 bytes\n    FILE_SIZE: int  # 4 bytes\n    FILE_DATE: str  # 16 bytes",
        "detail": "bin_system.splitapp_v2",
        "documentation": {}
    },
    {
        "label": "SparseChunkType",
        "kind": 6,
        "importPath": "bin_system.writer",
        "description": "bin_system.writer",
        "peekOfCode": "class SparseChunkType(IntEnum):\n    RAW = 0xCAC1\n    FILL = 0xCAC2\n    DONT_CARE = 0xCAC3\n    CRC32 = 0xCAC4\nclass SimgWriter(object):\n    file_header = \"<I4H4I\"\n    chunk_header = \"<2H2I\"\n    file_header_size = calcsize(file_header)\n    chunk_header_size = calcsize(chunk_header)",
        "detail": "bin_system.writer",
        "documentation": {}
    },
    {
        "label": "SimgWriter",
        "kind": 6,
        "importPath": "bin_system.writer",
        "description": "bin_system.writer",
        "peekOfCode": "class SimgWriter(object):\n    file_header = \"<I4H4I\"\n    chunk_header = \"<2H2I\"\n    file_header_size = calcsize(file_header)\n    chunk_header_size = calcsize(chunk_header)\n    def __init__(self, outf, start_block_offset = 0, end_block_offset = None, blocksize = 4096, debug = 0, dont_care = ()):\n        assert blocksize > 0\n        assert blocksize % 4 == 0\n        self.outf = outf\n        self.start_block_offset = start_block_offset",
        "detail": "bin_system.writer",
        "documentation": {}
    },
    {
        "label": "rul",
        "kind": 2,
        "importPath": "atrib",
        "description": "atrib",
        "peekOfCode": "def rul(st):\n    result = []\n    data = st.replace(' ','')\n    for i in data:\n        if not i.isdigit():\n            data=data.replace(i,'')\n    for _ in range(2) :\n        if data[0] != '0':\n             result.append(data[:4])\n             data = data[4:]",
        "detail": "atrib",
        "documentation": {}
    },
    {
        "label": "AvbError",
        "kind": 6,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "class AvbError(Exception):\n  \"\"\"Application-specific errors.\n  These errors represent issues for which a stack-trace should not be\n  presented.\n  Attributes:\n    message: Error message.\n  \"\"\"\n  def __init__(self, message):\n    Exception.__init__(self, message)\nclass Algorithm(object):",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "Algorithm",
        "kind": 6,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "class Algorithm(object):\n  \"\"\"Contains details about an algorithm.\n  See the avb_vbmeta_image.h file for more details about algorithms.\n  The constant |ALGORITHMS| is a dictionary from human-readable\n  names (e.g 'SHA256_RSA2048') to instances of this class.\n  Attributes:\n    algorithm_type: Integer code corresponding to |AvbAlgorithmType|.\n    hash_name: Empty or a name from |hashlib.algorithms|.\n    hash_num_bytes: Number of bytes used to store the hash.\n    signature_num_bytes: Number of bytes used to store the signature.",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "RSAPublicKey",
        "kind": 6,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "class RSAPublicKey(object):\n  \"\"\"Data structure used for a RSA public key.\n  Attributes:\n    exponent: The key exponent.\n    modulus: The key modulus.\n    num_bits: The key size.\n    key_path: The path to a key file.\n  \"\"\"\n  MODULUS_PREFIX = b'modulus='\n  def __init__(self, key_path):",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "ImageChunk",
        "kind": 6,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "class ImageChunk(object):\n  \"\"\"Data structure used for representing chunks in Android sparse files.\n  Attributes:\n    chunk_type: One of TYPE_RAW, TYPE_FILL, or TYPE_DONT_CARE.\n    chunk_offset: Offset in the sparse file where this chunk begins.\n    output_offset: Offset in de-sparsified file where output begins.\n    output_size: Number of bytes in output.\n    input_offset: Offset in sparse file for data if TYPE_RAW otherwise None.\n    fill_data: Blob with data to fill if TYPE_FILL otherwise None.\n  \"\"\"",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "ImageHandler",
        "kind": 6,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "class ImageHandler(object):\n  \"\"\"Abstraction for image I/O with support for Android sparse images.\n  This class provides an interface for working with image files that\n  may be using the Android Sparse Image format. When an instance is\n  constructed, we test whether it's an Android sparse file. If so,\n  operations will be on the sparse file by interpreting the sparse\n  format, otherwise they will be directly on the file. Either way the\n  operations do the same.\n  For reading, this interface mimics a file object - it has seek(),\n  tell(), and read() methods. For writing, only truncation",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "AvbDescriptor",
        "kind": 6,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "class AvbDescriptor(object):\n  \"\"\"Class for AVB descriptor.\n  See the |AvbDescriptor| C struct for more information.\n  Attributes:\n    tag: The tag identifying what kind of descriptor this is.\n    data: The data in the descriptor.\n  \"\"\"\n  SIZE = 16\n  FORMAT_STRING = ('!QQ')  # tag, num_bytes_following (descriptor header)\n  def __init__(self, data):",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "AvbPropertyDescriptor",
        "kind": 6,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "class AvbPropertyDescriptor(AvbDescriptor):\n  \"\"\"A class for property descriptors.\n  See the |AvbPropertyDescriptor| C struct for more information.\n  Attributes:\n    key: The key as string.\n    value: The value as bytes.\n  \"\"\"\n  TAG = 0\n  SIZE = 32\n  FORMAT_STRING = ('!QQ'  # tag, num_bytes_following (descriptor header)",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "AvbHashtreeDescriptor",
        "kind": 6,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "class AvbHashtreeDescriptor(AvbDescriptor):\n  \"\"\"A class for hashtree descriptors.\n  See the |AvbHashtreeDescriptor| C struct for more information.\n  Attributes:\n    dm_verity_version: dm-verity version used.\n    image_size: Size of the image, after rounding up to |block_size|.\n    tree_offset: Offset of the hash tree in the file.\n    tree_size: Size of the tree.\n    data_block_size: Data block size.\n    hash_block_size: Hash block size.",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "AvbHashDescriptor",
        "kind": 6,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "class AvbHashDescriptor(AvbDescriptor):\n  \"\"\"A class for hash descriptors.\n  See the |AvbHashDescriptor| C struct for more information.\n  Attributes:\n    image_size: Image size, in bytes.\n    hash_algorithm: Hash algorithm used as string.\n    partition_name: Partition name as string.\n    salt: Salt used as bytes.\n    digest: The hash value of salt and data combined as bytes.\n    flags: The descriptor flags (see avb_hash_descriptor.h).",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "AvbKernelCmdlineDescriptor",
        "kind": 6,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "class AvbKernelCmdlineDescriptor(AvbDescriptor):\n  \"\"\"A class for kernel command-line descriptors.\n  See the |AvbKernelCmdlineDescriptor| C struct for more information.\n  Attributes:\n    flags: Flags.\n    kernel_cmdline: The kernel command-line as string.\n  \"\"\"\n  TAG = 3\n  SIZE = 24\n  FORMAT_STRING = ('!QQ'  # tag, num_bytes_following (descriptor header)",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "AvbChainPartitionDescriptor",
        "kind": 6,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "class AvbChainPartitionDescriptor(AvbDescriptor):\n  \"\"\"A class for chained partition descriptors.\n  See the |AvbChainPartitionDescriptor| C struct for more information.\n  Attributes:\n    rollback_index_location: The rollback index location to use.\n    partition_name: Partition name as string.\n    public_key: The public key as bytes.\n  \"\"\"\n  TAG = 4\n  RESERVED = 64",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "AvbFooter",
        "kind": 6,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "class AvbFooter(object):\n  \"\"\"A class for parsing and writing footers.\n  Footers are stored at the end of partitions and point to where the\n  AvbVBMeta blob is located. They also contain the original size of\n  the image before AVB information was added.\n  Attributes:\n    magic: Magic for identifying the footer, see |MAGIC|.\n    version_major: The major version of avbtool that wrote the footer.\n    version_minor: The minor version of avbtool that wrote the footer.\n    original_image_size: Original image size.",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "AvbVBMetaHeader",
        "kind": 6,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "class AvbVBMetaHeader(object):\n  \"\"\"A class for parsing and writing AVB vbmeta images.\n  The attributes correspond to the |AvbVBMetaImageHeader| struct defined in\n  avb_vbmeta_image.h.\n  Attributes:\n    magic: Four bytes equal to \"AVB0\" (AVB_MAGIC).\n    required_libavb_version_major: The major version of libavb required for this\n        header.\n    required_libavb_version_minor: The minor version of libavb required for this\n        header.",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "Avb",
        "kind": 6,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "class Avb(object):\n  \"\"\"Business logic for avbtool command-line tool.\"\"\"\n  # Keep in sync with avb_ab_flow.h.\n  AB_FORMAT_NO_CRC = '!4sBB2xBBBxBBBx12x'\n  AB_MAGIC = b'\\0AB0'\n  AB_MAJOR_VERSION = 1\n  AB_MINOR_VERSION = 0\n  AB_MISC_METADATA_OFFSET = 2048\n  # Constants for maximum metadata size. These are used to give\n  # meaningful errors if the value passed in via --partition_size is",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "AvbTool",
        "kind": 6,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "class AvbTool(object):\n  \"\"\"Object for avbtool command-line tool.\"\"\"\n  def __init__(self):\n    \"\"\"Initializer method.\"\"\"\n    self.avb = Avb()\n  def _add_common_args(self, sub_parser):\n    \"\"\"Adds arguments used by several sub-commands.\n    Arguments:\n      sub_parser: The parser to add arguments to.\n    \"\"\"",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "get_release_string",
        "kind": 2,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "def get_release_string():\n  \"\"\"Calculates the release string to use in the VBMeta struct.\"\"\"\n  # Keep in sync with libavb/avb_version.c:avb_version_string().\n  return 'avbtool {}.{}.{}'.format(AVB_VERSION_MAJOR,\n                                   AVB_VERSION_MINOR,\n                                   AVB_VERSION_SUB)\ndef round_to_multiple(number, size):\n  \"\"\"Rounds a number up to nearest multiple of another number.\n  Arguments:\n    number: The number to round up.",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "round_to_multiple",
        "kind": 2,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "def round_to_multiple(number, size):\n  \"\"\"Rounds a number up to nearest multiple of another number.\n  Arguments:\n    number: The number to round up.\n    size: The multiple to round up to.\n  Returns:\n    If |number| is a multiple of |size|, returns |number|, otherwise\n    returns |number| + |size|.\n  \"\"\"\n  remainder = number % size",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "round_to_pow2",
        "kind": 2,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "def round_to_pow2(number):\n  \"\"\"Rounds a number up to the next power of 2.\n  Arguments:\n    number: The number to round up.\n  Returns:\n    If |number| is already a power of 2 then |number| is\n    returned. Otherwise the smallest power of 2 greater than |number|\n    is returned.\n  \"\"\"\n  return 2**((number - 1).bit_length())",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "encode_long",
        "kind": 2,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "def encode_long(num_bits, value):\n  \"\"\"Encodes a long to a bytearray() using a given amount of bits.\n  This number is written big-endian, e.g. with the most significant\n  bit first.\n  This is the reverse of decode_long().\n  Arguments:\n    num_bits: The number of bits to write, e.g. 2048.\n    value: The value to write.\n  Returns:\n    A bytearray() with the encoded long.",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "decode_long",
        "kind": 2,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "def decode_long(blob):\n  \"\"\"Decodes a long from a bytearray() using a given amount of bits.\n  This number is expected to be in big-endian, e.g. with the most\n  significant bit first.\n  This is the reverse of encode_long().\n  Arguments:\n    blob: A bytearray() with the encoded long.\n  Returns:\n    The decoded value.\n  \"\"\"",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "egcd",
        "kind": 2,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "def egcd(a, b):\n  \"\"\"Calculate greatest common divisor of two numbers.\n  This implementation uses a recursive version of the extended\n  Euclidian algorithm.\n  Arguments:\n    a: First number.\n    b: Second number.\n  Returns:\n    A tuple (gcd, x, y) that where |gcd| is the greatest common\n    divisor of |a| and |b| and |a|*|x| + |b|*|y| = |gcd|.",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "modinv",
        "kind": 2,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "def modinv(a, m):\n  \"\"\"Calculate modular multiplicative inverse of |a| modulo |m|.\n  This calculates the number |x| such that |a| * |x| == 1 (modulo\n  |m|). This number only exists if |a| and |m| are co-prime - |None|\n  is returned if this isn't true.\n  Arguments:\n    a: The number to calculate a modular inverse of.\n    m: The modulo to use.\n  Returns:\n    The modular multiplicative inverse of |a| and |m| or |None| if",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "parse_number",
        "kind": 2,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "def parse_number(string):\n  \"\"\"Parse a string as a number.\n  This is just a short-hand for int(string, 0) suitable for use in the\n  |type| parameter of |ArgumentParser|'s add_argument() function. An\n  improvement to just using type=int is that this function supports\n  numbers in other bases, e.g. \"0x1234\".\n  Arguments:\n    string: The string to parse.\n  Returns:\n    The parsed integer.",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "lookup_algorithm_by_type",
        "kind": 2,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "def lookup_algorithm_by_type(alg_type):\n  \"\"\"Looks up algorithm by type.\n  Arguments:\n    alg_type: The integer representing the type.\n  Returns:\n    A tuple with the algorithm name and an |Algorithm| instance.\n  Raises:\n    Exception: If the algorithm cannot be found\n  \"\"\"\n  for alg_name in ALGORITHMS:",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "lookup_hash_size_by_type",
        "kind": 2,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "def lookup_hash_size_by_type(alg_type):\n  \"\"\"Looks up hash size by type.\n  Arguments:\n    alg_type: The integer representing the type.\n  Returns:\n    The corresponding hash size.\n  Raises:\n    AvbError: If the algorithm cannot be found.\n  \"\"\"\n  for alg_name in ALGORITHMS:",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "verify_vbmeta_signature",
        "kind": 2,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "def verify_vbmeta_signature(vbmeta_header, vbmeta_blob):\n  \"\"\"Checks that signature in a vbmeta blob was made by the embedded public key.\n  Arguments:\n    vbmeta_header: A AvbVBMetaHeader.\n    vbmeta_blob: The whole vbmeta blob, including the header as bytes or\n        bytearray.\n  Returns:\n    True if the signature is valid and corresponds to the embedded\n    public key. Also returns True if the vbmeta blob is not signed.\n  Raises:",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "create_avb_hashtree_hasher",
        "kind": 2,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "def create_avb_hashtree_hasher(algorithm, salt):\n  \"\"\"Create the hasher for AVB hashtree based on the input algorithm.\"\"\"\n  if algorithm.lower() == 'blake2b-256':\n    return hashlib.new('blake2b', salt, digest_size=32)\n  return hashlib.new(algorithm, salt)\nclass ImageChunk(object):\n  \"\"\"Data structure used for representing chunks in Android sparse files.\n  Attributes:\n    chunk_type: One of TYPE_RAW, TYPE_FILL, or TYPE_DONT_CARE.\n    chunk_offset: Offset in the sparse file where this chunk begins.",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "parse_descriptors",
        "kind": 2,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "def parse_descriptors(data):\n  \"\"\"Parses a blob of data into descriptors.\n  Arguments:\n    data: Encoded descriptors as bytes.\n  Returns:\n    A list of instances of objects derived from AvbDescriptor. For\n    unknown descriptors, the class AvbDescriptor is used.\n  \"\"\"\n  o = 0\n  ret = []",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "calc_hash_level_offsets",
        "kind": 2,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "def calc_hash_level_offsets(image_size, block_size, digest_size):\n  \"\"\"Calculate the offsets of all the hash-levels in a Merkle-tree.\n  Arguments:\n    image_size: The size of the image to calculate a Merkle-tree for.\n    block_size: The block size, e.g. 4096.\n    digest_size: The size of each hash, e.g. 32 for SHA-256.\n  Returns:\n    A tuple where the first argument is an array of offsets and the\n    second is size of the tree, in bytes.\n  \"\"\"",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "calc_fec_data_size",
        "kind": 2,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "def calc_fec_data_size(image_size, num_roots):\n  \"\"\"Calculates how much space FEC data will take.\n  Arguments:\n    image_size: The size of the image.\n    num_roots: Number of roots.\n  Returns:\n    The number of bytes needed for FEC for an image of the given size\n    and with the requested number of FEC roots.\n  Raises:\n    ValueError: If output from the 'fec' tool is invalid.",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "generate_fec_data",
        "kind": 2,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "def generate_fec_data(image_filename, num_roots):\n  \"\"\"Generate FEC codes for an image.\n  Arguments:\n    image_filename: The filename of the image.\n    num_roots: Number of roots.\n  Returns:\n    The FEC data blob as bytes.\n  Raises:\n    ValueError: If calling the 'fec' tool failed or the output is invalid.\n  \"\"\"",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "generate_hash_tree",
        "kind": 2,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "def generate_hash_tree(image, image_size, block_size, hash_alg_name, salt,\n                       digest_padding, hash_level_offsets, tree_size):\n  \"\"\"Generates a Merkle-tree for a file.\n  Arguments:\n    image: The image, as a file.\n    image_size: The size of the image.\n    block_size: The block size, e.g. 4096.\n    hash_alg_name: The hash algorithm, e.g. 'sha256' or 'sha1'.\n    salt: The salt to use.\n    digest_padding: The padding for each digest.",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "AVB_VERSION_MAJOR",
        "kind": 5,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "AVB_VERSION_MAJOR = 1\nAVB_VERSION_MINOR = 2\nAVB_VERSION_SUB = 0\n# Keep in sync with libavb/avb_footer.h.\nAVB_FOOTER_VERSION_MAJOR = 1\nAVB_FOOTER_VERSION_MINOR = 0\nAVB_VBMETA_IMAGE_FLAGS_HASHTREE_DISABLED = 1\n# Configuration for enabling logging of calls to avbtool.\nAVB_INVOCATION_LOGFILE = os.environ.get('AVB_INVOCATION_LOGFILE')\nclass AvbError(Exception):",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "AVB_VERSION_MINOR",
        "kind": 5,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "AVB_VERSION_MINOR = 2\nAVB_VERSION_SUB = 0\n# Keep in sync with libavb/avb_footer.h.\nAVB_FOOTER_VERSION_MAJOR = 1\nAVB_FOOTER_VERSION_MINOR = 0\nAVB_VBMETA_IMAGE_FLAGS_HASHTREE_DISABLED = 1\n# Configuration for enabling logging of calls to avbtool.\nAVB_INVOCATION_LOGFILE = os.environ.get('AVB_INVOCATION_LOGFILE')\nclass AvbError(Exception):\n  \"\"\"Application-specific errors.",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "AVB_VERSION_SUB",
        "kind": 5,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "AVB_VERSION_SUB = 0\n# Keep in sync with libavb/avb_footer.h.\nAVB_FOOTER_VERSION_MAJOR = 1\nAVB_FOOTER_VERSION_MINOR = 0\nAVB_VBMETA_IMAGE_FLAGS_HASHTREE_DISABLED = 1\n# Configuration for enabling logging of calls to avbtool.\nAVB_INVOCATION_LOGFILE = os.environ.get('AVB_INVOCATION_LOGFILE')\nclass AvbError(Exception):\n  \"\"\"Application-specific errors.\n  These errors represent issues for which a stack-trace should not be",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "AVB_FOOTER_VERSION_MAJOR",
        "kind": 5,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "AVB_FOOTER_VERSION_MAJOR = 1\nAVB_FOOTER_VERSION_MINOR = 0\nAVB_VBMETA_IMAGE_FLAGS_HASHTREE_DISABLED = 1\n# Configuration for enabling logging of calls to avbtool.\nAVB_INVOCATION_LOGFILE = os.environ.get('AVB_INVOCATION_LOGFILE')\nclass AvbError(Exception):\n  \"\"\"Application-specific errors.\n  These errors represent issues for which a stack-trace should not be\n  presented.\n  Attributes:",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "AVB_FOOTER_VERSION_MINOR",
        "kind": 5,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "AVB_FOOTER_VERSION_MINOR = 0\nAVB_VBMETA_IMAGE_FLAGS_HASHTREE_DISABLED = 1\n# Configuration for enabling logging of calls to avbtool.\nAVB_INVOCATION_LOGFILE = os.environ.get('AVB_INVOCATION_LOGFILE')\nclass AvbError(Exception):\n  \"\"\"Application-specific errors.\n  These errors represent issues for which a stack-trace should not be\n  presented.\n  Attributes:\n    message: Error message.",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "AVB_VBMETA_IMAGE_FLAGS_HASHTREE_DISABLED",
        "kind": 5,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "AVB_VBMETA_IMAGE_FLAGS_HASHTREE_DISABLED = 1\n# Configuration for enabling logging of calls to avbtool.\nAVB_INVOCATION_LOGFILE = os.environ.get('AVB_INVOCATION_LOGFILE')\nclass AvbError(Exception):\n  \"\"\"Application-specific errors.\n  These errors represent issues for which a stack-trace should not be\n  presented.\n  Attributes:\n    message: Error message.\n  \"\"\"",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "AVB_INVOCATION_LOGFILE",
        "kind": 5,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "AVB_INVOCATION_LOGFILE = os.environ.get('AVB_INVOCATION_LOGFILE')\nclass AvbError(Exception):\n  \"\"\"Application-specific errors.\n  These errors represent issues for which a stack-trace should not be\n  presented.\n  Attributes:\n    message: Error message.\n  \"\"\"\n  def __init__(self, message):\n    Exception.__init__(self, message)",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "ALGORITHMS",
        "kind": 5,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "ALGORITHMS = {\n    'NONE': Algorithm(\n        algorithm_type=0,        # AVB_ALGORITHM_TYPE_NONE\n        hash_name='',\n        hash_num_bytes=0,\n        signature_num_bytes=0,\n        public_key_num_bytes=0,\n        padding=b''),\n    'SHA256_RSA2048': Algorithm(\n        algorithm_type=1,        # AVB_ALGORITHM_TYPE_SHA256_RSA2048",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "DESCRIPTOR_CLASSES",
        "kind": 5,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "DESCRIPTOR_CLASSES = [\n    AvbPropertyDescriptor, AvbHashtreeDescriptor, AvbHashDescriptor,\n    AvbKernelCmdlineDescriptor, AvbChainPartitionDescriptor\n]\ndef parse_descriptors(data):\n  \"\"\"Parses a blob of data into descriptors.\n  Arguments:\n    data: Encoded descriptors as bytes.\n  Returns:\n    A list of instances of objects derived from AvbDescriptor. For",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "FEC_FOOTER_FORMAT",
        "kind": 5,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "FEC_FOOTER_FORMAT = '<LLLLLQ32s'\nFEC_MAGIC = 0xfecfecfe\ndef calc_fec_data_size(image_size, num_roots):\n  \"\"\"Calculates how much space FEC data will take.\n  Arguments:\n    image_size: The size of the image.\n    num_roots: Number of roots.\n  Returns:\n    The number of bytes needed for FEC for an image of the given size\n    and with the requested number of FEC roots.",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "FEC_MAGIC",
        "kind": 5,
        "importPath": "avbtool",
        "description": "avbtool",
        "peekOfCode": "FEC_MAGIC = 0xfecfecfe\ndef calc_fec_data_size(image_size, num_roots):\n  \"\"\"Calculates how much space FEC data will take.\n  Arguments:\n    image_size: The size of the image.\n    num_roots: Number of roots.\n  Returns:\n    The number of bytes needed for FEC for an image of the given size\n    and with the requested number of FEC roots.\n  Raises:",
        "detail": "avbtool",
        "documentation": {}
    },
    {
        "label": "FindStringInByteFile",
        "kind": 2,
        "importPath": "find",
        "description": "find",
        "peekOfCode": "def FindStringInByteFile(word,file):\n    findword =  bytes(word, 'utf-8')\n    detctbuild = bytes(\"begin build properties\", 'utf-8')\n    with open(file, \"r+b\") as f:\n            step = mmap.ALLOCATIONGRANULARITY\n            offset = 0\n            size = os.stat(file).st_size\n            map_ = mmap.mmap(f.fileno(), length=step)\n            while True:\n                    offset += step",
        "detail": "find",
        "documentation": {}
    },
    {
        "label": "existf",
        "kind": 2,
        "importPath": "fixmoto",
        "description": "fixmoto",
        "peekOfCode": "def existf(filename):\n\ttry:\n\t\tif os.path.isdir(filename):\n\t\t\treturn 2\n\t\tif os.stat(filename).st_size > 0:\n\t\t\treturn 0\n\t\telse:\n\t\t\treturn 1\n\texcept OSError:\n\t\treturn 2",
        "detail": "fixmoto",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "fixmoto",
        "description": "fixmoto",
        "peekOfCode": "parser = argparse.ArgumentParser(description=\"Fix Motorola img files to be valid ext4.\")\nparser.add_argument(\"broken\", help=\"Path to the broken.img\")\nparser.add_argument(\"fixed\", help=\"Path to the new fixed.img\")\nargs = parser.parse_args()\nb = args.broken\nn = args.fixed\nif existf(b) != 0:\n    print('\\n'+b+' does not exist.\\n')\n    sys.exit()\nwith open(b, 'rb') as f:",
        "detail": "fixmoto",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "fixmoto",
        "description": "fixmoto",
        "peekOfCode": "args = parser.parse_args()\nb = args.broken\nn = args.fixed\nif existf(b) != 0:\n    print('\\n'+b+' does not exist.\\n')\n    sys.exit()\nwith open(b, 'rb') as f:\n    data = f.read(500000)\nmoto = re.search(b'\\x4d\\x4f\\x54\\x4f', data)\nif not moto:",
        "detail": "fixmoto",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "fixmoto",
        "description": "fixmoto",
        "peekOfCode": "b = args.broken\nn = args.fixed\nif existf(b) != 0:\n    print('\\n'+b+' does not exist.\\n')\n    sys.exit()\nwith open(b, 'rb') as f:\n    data = f.read(500000)\nmoto = re.search(b'\\x4d\\x4f\\x54\\x4f', data)\nif not moto:\n    print('\\nThis does not appear to be a Motorola img\\n')",
        "detail": "fixmoto",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "fixmoto",
        "description": "fixmoto",
        "peekOfCode": "n = args.fixed\nif existf(b) != 0:\n    print('\\n'+b+' does not exist.\\n')\n    sys.exit()\nwith open(b, 'rb') as f:\n    data = f.read(500000)\nmoto = re.search(b'\\x4d\\x4f\\x54\\x4f', data)\nif not moto:\n    print('\\nThis does not appear to be a Motorola img\\n')\n    sys.exit()",
        "detail": "fixmoto",
        "documentation": {}
    },
    {
        "label": "moto",
        "kind": 5,
        "importPath": "fixmoto",
        "description": "fixmoto",
        "peekOfCode": "moto = re.search(b'\\x4d\\x4f\\x54\\x4f', data)\nif not moto:\n    print('\\nThis does not appear to be a Motorola img\\n')\n    sys.exit()\nresult = []\nfor i in re.finditer(b'\\x53\\xEF', data):\n    result.append(i.start() - 1080)\noffset = 0\nfor i in result:\n    if data[i] == 0:",
        "detail": "fixmoto",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "fixmoto",
        "description": "fixmoto",
        "peekOfCode": "result = []\nfor i in re.finditer(b'\\x53\\xEF', data):\n    result.append(i.start() - 1080)\noffset = 0\nfor i in result:\n    if data[i] == 0:\n        offset = i\n        break        \nif offset > 0:\n    print('\\nFixing '+b+' ...')",
        "detail": "fixmoto",
        "documentation": {}
    },
    {
        "label": "offset",
        "kind": 5,
        "importPath": "fixmoto",
        "description": "fixmoto",
        "peekOfCode": "offset = 0\nfor i in result:\n    if data[i] == 0:\n        offset = i\n        break        \nif offset > 0:\n    print('\\nFixing '+b+' ...')\n    with open(n, 'wb') as o, open(b, 'rb') as f:\n        data = f.seek(offset)\n        data = f.read(15360)",
        "detail": "fixmoto",
        "documentation": {}
    },
    {
        "label": "FindStringInByteFile",
        "kind": 2,
        "importPath": "ver1",
        "description": "ver1",
        "peekOfCode": "def FindStringInByteFile(word,file):\n    findword =  bytes(word, 'utf-8')\n    with open(file, \"r+b\") as f:\n        for line in f:\n            if findword in line:\n               return line.__str__()[2:len(line.__str__())-3]\nif __name__ == '__main__': \n\t    print(FindStringInByteFile(sys.argv[1], sys.argv[2]))",
        "detail": "ver1",
        "documentation": {}
    }
]